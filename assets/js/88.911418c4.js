(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{599:function(r,e,o){"use strict";o.r(e);var n=o(5),t=Object(n.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("p",[r._v("访问系统的一些资源的时候，不可避免的会遇到一些错误，我们需要告诉用户或者提醒我们自己遇到什么问题了，方便定位解决。比如移除指定路径文件或者目录的时候，可能文件不存在或者路径有问题等等，我们需要知道究竟为什么不能成功移除，这时候错误信息就很重要了，看下系统是怎么设计这类 API 的。"),e("code",[r._v("- (BOOL)removeItemAtPath:(NSString *)path error:(NSError * _Nullable *)error;")])]),r._v(" "),e("p",[r._v("使用类似 API 的时候通常都是传递 "),e("code",[r._v("NSError * _Nullable *")]),r._v(" 这种参数，目的是为了延长 error 的初始化时机，让 error 在执行任务的时候再初始化并赋予错误信息。")]),r._v(" "),e("p",[e("code",[r._v("NSError")]),r._v(" 里面包含的信息很丰富。主要是三个，domain，code 和错误相关的信息。code 是和 domain 相关的。")]),r._v(" "),e("p",[r._v("一个 NSError 的最佳实践是是使用倒序域名方式，这样可以有效避免 NSError 的域名重复。然后根据倒序域名定义错误 code，域名不重复的话，这些 code 可以随意定制，是不会和别的域名下的 code 冲突的。具体看下面 demo")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('static NSString *const kUserInfoDomain = @"com.app.userinfo";\n\ntypedef enum : NSUInteger {\n    AUIUserNotExist = 0,\n    AUIUserNameEmpty,\n} AUIErrorCode;\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self fetchUserInfoWithError:&error];\n}\n\n- (NSString *)fetchUserInfoWithError:(NSError **)error {\n    NSDictionary *errInfo =@{NSLocalizedDescriptionKey:@"用户不存在"};\n    - (void)btnPressed:(id)sender {\n    NSError *error = nil;\n    [self fetchUserInfoWithError:error];\n    NSLog(@"error = %@",error);\n}\n//模拟一次错误获取\n- (NSString *)fetchUserInfoWithError:(NSError **)error {\n    NSDictionary *errInfo = @{NSLocalizedDescriptionKey:@"用户不存在"};\n    if(error != NULL){\n        *error = [NSError errorWithDomain:kUserInfoDomain code:AUIUserNotExist userInfo:errInfo];\n    }\n    return nil;\n}\n')])])]),e("p",[r._v("以上错误处理代码中需要注意的一点就是 error 的判断 "),e("code",[r._v("if(error != NULL)")]),r._v(" 加这一行的作用是区分一下两种调用方式")]),r._v(" "),e("ol",[e("li",[e("code",[r._v("[self fetchUserInfoWithError:nil];")])]),r._v(" "),e("li",[e("code",[r._v("NSError *error = nil; [self fetchUserInfoWithError:error];")])])]),r._v(" "),e("p",[r._v("如果是像前者一样调用的话，是不会走进这个 "),e("code",[r._v("if(error != NULL)")]),r._v("分支判断，我们没必要为这种情况单独初始化一个 "),e("code",[r._v("error")]),r._v(" 实例。")]),r._v(" "),e("p",[r._v("以上，在帮别的同事封装可调用 API 的时候增加必要的 NSError 参数，不仅方便别人，其实也是方便自己。")]),r._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[r._v("#")]),r._v(" 参考")]),r._v(" "),e("p",[e("a",{attrs:{href:"http://nshipster.com/nserror/",target:"_blank",rel:"noopener noreferrer"}},[r._v("NSError"),e("OutboundLink")],1),r._v(" "),e("a",{attrs:{href:"https://stackoverflow.com/questions/3276127/best-practice-nserror-domains-and-codes-for-your-own-project-app",target:"_blank",rel:"noopener noreferrer"}},[r._v("Best Practice - NSError domains and codes for your own project/app"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=t.exports}}]);