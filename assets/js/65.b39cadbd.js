(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{393:function(e,o,t){e.exports=t.p+"assets/img/cocoapods_1.66946a7e.png"},636:function(e,o,t){"use strict";t.r(o);var r=t(5),a=Object(r.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("最近使用 Cocoapods 的时候遇到一个问题，就是在 Podfile 中引入 iOS 调试库 FLEX 后，在工程源文件里通过  "),o("code",[e._v("import FLEX")]),e._v(" 引入的时候，编译工程报错：  "),o("code",[e._v("No such module 'FLEX’")]),e._v(" 。")]),e._v(" "),o("div",{staticClass:"language-swift extra-class"},[o("pre",{pre:!0,attrs:{class:"language-swift"}},[o("code",[e._v("pod '"),o("span",{pre:!0,attrs:{class:"token constant"}},[e._v("FLEX")]),e._v("'"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("git "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" 'https"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("//")]),e._v("github"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("com"),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),o("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("FLEXTool")]),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),o("span",{pre:!0,attrs:{class:"token constant"}},[e._v("FLEX")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("git'"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("branch "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" 'master'\n")])])]),o("p",[e._v("通过调试检查后发现有两个解决方案：")]),e._v(" "),o("ol",[o("li",[e._v("Podfile 文件里少了一行语句 "),o("code",[e._v("use_frameworks!")]),e._v(" ，加上之后重新 "),o("code",[e._v("pod install")]),e._v(" 就好了")]),e._v(" "),o("li",[e._v("在 "),o("code",[e._v("pod ‘FLEX’")]),e._v(" 后面加上一句 "),o("code",[e._v(":modular_headers => true")]),e._v(" 也能解决编译报错的问题")])]),e._v(" "),o("p",[e._v("分析一下这两个解决方案")]),e._v(" "),o("h2",{attrs:{id:"use-frameworks-方式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#use-frameworks-方式"}},[e._v("#")]),e._v(" use_frameworks! 方式")]),e._v(" "),o("p",[e._v("正常我们 "),o("code",[e._v("pod init")]),e._v(" 的时候生成的 Podfile 里面默认都是带  "),o("code",[e._v("use_frameworks!")]),e._v("，Cocoapods 是在 0.36 版本的时候引入 "),o("code",[e._v("use_frameworks!")]),e._v(" ，目的通过动态库(framework)而不是静态库(static libraries) 的方式去整合工程。")]),e._v(" "),o("blockquote",[o("p",[e._v("framework 有可能是静态库的，但当苹果提到 framework 基本上就是暗示是动态库（When Apple and Xcode refer to frameworks, dynamic is typically implied.） 参考这里 "),o("a",{attrs:{href:"https://blog.cocoapods.org/CocoaPods-1.4.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://blog.cocoapods.org/CocoaPods-1.4.0/"),o("OutboundLink")],1)])]),e._v(" "),o("p",[e._v("事情背景是 2014 年发的 iOS8 引入开始支持动态库引入，同时发布 Swift 语言，同时苹果不允许构建包含 Swift 代码的静态库。所以我们想要使用 Swift 语言来封装库的话唯一的选择就是生成动态库。所以 Podfile 如果不使用 "),o("code",[e._v("use_frameworks!")]),e._v(" 的话，是不能整合包含 Swift 代码的第三方 Pod 库。")]),e._v(" "),o("blockquote",[o("p",[e._v("苹果不允许构建包含 Swift 代码的静态库的原因是？ABI 没稳定造成后续的兼容问题。")])]),e._v(" "),o("p",[e._v("使用 "),o("code",[e._v("use_frameworks!")]),e._v(" 之后，系统会生成 FLEX module，工程可以通过直接 import 的形式引入 FLEX module")]),e._v(" "),o("div",{staticClass:"language-swift extra-class"},[o("pre",{pre:!0,attrs:{class:"language-swift"}},[o("code",[o("span",{pre:!0,attrs:{class:"token other-directive property"}},[e._v("#FLEX")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("modulemap\nframework module "),o("span",{pre:!0,attrs:{class:"token constant"}},[e._v("FLEX")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  umbrella header "),o("span",{pre:!0,attrs:{class:"token string-literal"}},[o("span",{pre:!0,attrs:{class:"token string"}},[e._v('"FLEX-umbrella.h"')])]),e._v("\n\n  export "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("\n  module "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" export "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),o("h2",{attrs:{id:"modular-headers-⇒-true-的方式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#modular-headers-⇒-true-的方式"}},[e._v("#")]),e._v(" :modular_headers ⇒ true  的方式")]),e._v(" "),o("p",[e._v("如果主工程是用 Swift 语言，同时使用 OC 语言编写的库来说，不使用 "),o("code",[e._v("use_frameworks!")]),e._v(" 的时候，build 出来的 FLEX 结果是静态库 libFLEX.a，并没有生成 module，所以也就没有办法通过 import 的方式引入，加上  "),o("code",[e._v(":modular_headers ⇒ true")]),e._v(" 的时候会在编译相关目录里添加 module 的支持，这样就能继续通过 import 的方式引入")]),e._v(" "),o("p",[o("img",{attrs:{src:t(393),alt:"Untitled"}})]),e._v(" "),o("p",[e._v("你可能会问如果不使用 "),o("code",[e._v("use_frameworks!")]),e._v(" 那我有包含 Swift 代码的库咋办呢？苹果从 Xcode9 开始就支持包含 Swift 代码的静态库了（大量的动态库会影响启动速度），Cocoapods 也发布了对应的更新 1.5.0，开发者没有必要一定在 Podfile 里强制使用 "),o("code",[e._v("use_frameworks!")]),e._v("。")]),e._v(" "),o("p",[e._v("同时如果我们的工程是 Swift 语言的，使用的库是包含 OC 的代码的话，就必须给包含 OC 的库开启 modular headers 来支持 module，但是 Swift 库不是必须的，因为 Swift 库天生支持 module。在我们的例子里，FLEX 就是 OC 语言的库，所以必须开启 modular headers，开启后效果参考上面的效果图。")]),e._v(" "),o("p",[e._v("多说一句 module，Module 我理解并不是单是 Swift 的概念，而是 LLVM 编译里面的一个概念，module 要解决的问题本质上是传统 C/C++/OC 里面的 #include 导入方式的弊端。通过引入 module 来提升编译效率。所以 Module 本质上就还是和库类似的概念，可能比库覆盖的面更广一些。官方的说法是最小的编译单元，感觉说的还是比较准确的。")]),e._v(" "),o("p",[e._v("[2023-02-21]")]),e._v(" "),o("p",[e._v("补充两个使用 "),o("code",[e._v("use_frameworks!")]),e._v(" 和 "),o("code",[e._v(":modular_headers => true/false")]),e._v(" 的使用规范")]),e._v(" "),o("ol",[o("li",[e._v("如果 Podfile 里开启 "),o("code",[e._v("use_frameworks!")]),e._v("，那就算你在某个 Pod 后面加了 "),o("code",[e._v(":modular_headers => true")]),e._v(" 也不会生效。")]),e._v(" "),o("li",[e._v("没有办法让 use_framework 单独对某几个 Pod 生效，参考这里 "),o("a",{attrs:{href:"https://github.com/CocoaPods/CocoaPods/issues/3839",target:"_blank",rel:"noopener noreferrer"}},[e._v("use_frameworks! for only some pods #3839"),o("OutboundLink")],1)])]),e._v(" "),o("p",[e._v("[2023-02-22]")]),e._v(" "),o("p",[e._v("这两天遇到另外一个问题是，我自己私有库 "),o("code",[e._v("private_lib")]),e._v(" 中使用到了第三方的库 "),o("code",[e._v("SDWebImage")]),e._v(" 这样的 OC 库，在主工程使用如下配置引用 "),o("code",[e._v("private_lib")]),e._v(" 库。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("#use_frameworks!\npod 'private_lib', :modular_headers => true\n")])])]),o("p",[e._v("执行 "),o("code",[e._v("pod install")]),e._v(" 报错信息如下")]),e._v(" "),o("blockquote",[o("p",[e._v("The Swift pod "),o("code",[e._v("private_lib")]),e._v(" depends upon "),o("code",[e._v("SDWebImage")]),e._v(", which do not define modules. To opt into those targets generating module maps (which is necessary to import them from Swift when building as static libraries), you may set "),o("code",[e._v("use_modular_headers!")]),e._v(" globally in your Podfile, or specify "),o("code",[e._v(":modular_headers => true")]),e._v(" for particular dependencies.")])]),e._v(" "),o("p",[e._v("本质上还是 "),o("code",[e._v("private_lib")]),e._v(" 里面的 "),o("code",[e._v("SDWebImage")]),e._v(" 没有配置 module_headers 的原因。但是如何在私有库中对这项进行配置呢？在搜索答案的过程中，我找到这个 issue: "),o("a",{attrs:{href:"https://github.com/lottie-react-native/lottie-react-native/issues/784",target:"_blank",rel:"noopener noreferrer"}},[e._v("The following Swift pods cannot yet be integrated as static libraries: #784"),o("OutboundLink")],1),e._v("，进而发现了 Cocoapods 的一个配置 "),o("code",[e._v("use_frameworks! :linkage => :static")]),e._v(" 这是从 "),o("a",{attrs:{href:"https://blog.cocoapods.org/CocoaPods-1.9.0-beta/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cocoapods 1.9.0"),o("OutboundLink")],1),e._v(" 引入的，目的是给使用者更多权限去控制 Pods 打包和链接方式。")]),e._v(" "),o("p",[e._v("我自己尝试的结果是当使用 "),o("code",[e._v("use_frameworks! :linkage => :static")]),e._v(" 的时候，Pods 都会被打包成静态库但是是 .framework 格式的，而不是 .a 格式的，.framework 格式比 .a 格式可以更好的去管理资源，当然最后也是静态链接到我们的主程序。我们使用这个配置就能不需要再使用 "),o("code",[e._v("use_modular_headers")]),e._v(" 了，因为 framework 自动会生成 module。")]),e._v(" "),o("p",[e._v("最终我选择了这种配置方式来进行配置，而不去使用动态库的方式，为了让程序更快的启动。官方的这篇 "),o("a",{attrs:{href:"https://github.com/CocoaPods/CocoaPods/issues/9099",target:"_blank",rel:"noopener noreferrer"}},[e._v("issue"),o("OutboundLink")],1),e._v(" 也给出了详细的修改动机。")]),e._v(" "),o("p",[e._v("参考地址:")]),e._v(" "),o("ol",[o("li",[o("a",{attrs:{href:"https://blog.cocoapods.org/CocoaPods-0.36/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CocoaPods 0.36 - Framework and Swift Support"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://blog.cocoapods.org/CocoaPods-1.5.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CocoaPods 1.5.0 — Swift Static Libraries"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://andelf.github.io/blog/2014/06/19/modules-for-swift/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Module System of Swift (简析 Swift 的模块系统)"),o("OutboundLink")],1),e._v("   #module 介绍的比较详细")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://blog.51cto.com/u_15329201/3370400",target:"_blank",rel:"noopener noreferrer"}},[e._v("为什么应该用模块取代C/C++中的头文件？ 转"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://blog.cocoapods.org/CocoaPods-1.9.0-beta/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CocoaPods 1.9 Beta has arrived!"),o("OutboundLink")],1)])]),e._v(" "),o("Vssue",{attrs:{title:e.Cocoapods使用报错NoSuchModule}})],1)}),[],!1,null,null,null);o.default=a.exports}}]);