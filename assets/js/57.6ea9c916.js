(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{323:function(t,a,e){t.exports=e.p+"assets/img/wechat_qrcode.c0c8a471.png"},616:function(t,a,e){"use strict";e.r(a);var n=e(5),s=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"什么是钻石合约"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是钻石合约"}},[t._v("#")]),t._v(" 什么是钻石合约？")]),t._v(" "),a("p",[t._v("钻石合约是 EIP-2535 提案中用到的术语，这个 EIP-2535 是一个模块化智能合约系统的标准，可以在部署后扩展。")]),t._v(" "),a("h2",{attrs:{id:"钻石合约的优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#钻石合约的优势"}},[t._v("#")]),t._v(" 钻石合约的优势")]),t._v(" "),a("p",[t._v("钻石合约的优势如下")]),t._v(" "),a("ol",[a("li",[t._v("单个地址可以管理无限的合约方法。主要是方便调用者调用，以往的包含多个智能合约的项目，调用者需要维护多个地址去和合约交互，使用钻石合约的话，调用者只需要和一个地址交互就 OK 了。")]),t._v(" "),a("li",[t._v("合约可以突破 24KB 大小的合约大小限制。以往如果合约大小超过 24KB 的话我们需要优化合约大小，让合约尽可能在 24KB 以下，比如拆分合约等等。但是这样会引入更多的合约地址，维护边的更加麻烦。")]),t._v(" "),a("li",[t._v("钻石合约提供了一种组织合约代码和数据的方法。面对比较复杂的合约，钻石合约提供了相对比较好的结构设计，让不同的功能组合链接的时候更加有效率。")]),t._v(" "),a("li",[t._v("钻石合约也支持合约升级。因为钻石合约可以管理几乎无限的合约方法，实现钻石合约升级也就不是难事。")])]),t._v(" "),a("h2",{attrs:{id:"理解钻石合约机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解钻石合约机制"}},[t._v("#")]),t._v(" 理解钻石合约机制")]),t._v(" "),a("h3",{attrs:{id:"术语理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#术语理解"}},[t._v("#")]),t._v(" 术语理解")]),t._v(" "),a("p",[a("code",[t._v("Facet")]),t._v(": 其实就是逻辑合约，就是我们的业务合约")]),t._v(" "),a("p",[a("code",[t._v("Diamond")]),t._v(": 是代理合约")]),t._v(" "),a("p",[a("code",[t._v("DiamondCut")]),t._v(": 是维护代理合约逻辑合约里的方法和地址关系的一个类，我觉得可以把 DiamondCut 理解成一个 HUB，负责插拔我们业务合约的一个类。")]),t._v(" "),a("p",[a("code",[t._v("DiamondLoupe")]),t._v(": 基本上提供的都是 view 方法，查询逻辑合约提供什么方法，以及方法对应的逻辑合约地址.")]),t._v(" "),a("p",[t._v("这些术语可以参考登链社区的"),a("a",{attrs:{href:"https://learnblockchain.cn/article/1398",target:"_blank",rel:"noopener noreferrer"}},[t._v("这篇文章"),a("OutboundLink")],1),t._v("的说明，这个比喻能很好的建立对这些概念的更加直观的理解。")]),t._v(" "),a("blockquote",[a("p",[t._v("此外，术语“钻石”用来建立一个形象的概念，用于了解其如何工作。真正的钻石有不同的侧面，叫做切面（facet）。可以设想，一个在以太坊钻石合约也有不同的切面。每一个钻石借用功能的合约都是不同的侧面或切面（facet）。\n钻石标准使用类比的方式扩展了“钻石切割”的功能 ，用于增加，替换，或删除切面和功能。这类似于给予一个真正的钻石新切面，而是通过合约来切割。\n此外，钻石标准提供了称为“放大镜(The Loupe)”的功能，返回关于切面的信息和钻石存在的功能。在钻石行业，“放大镜”是一种用来检查钻石的工具。")])]),t._v(" "),a("p",[t._v("钻石合约本质上还是代理模式，代理去解决合约升级拓展的时候通常需要解决两个问题，第一个就是方法转发的问题，第二个就是数据存储冲突的问题。")]),t._v(" "),a("h3",{attrs:{id:"方法转发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法转发"}},[t._v("#")]),t._v(" 方法转发")]),t._v(" "),a("p",[t._v("具体的实现官方文档如下")]),t._v(" "),a("blockquote",[a("p",[t._v("A diamond stores within it a mapping of function selector to facet address, for example selectorToFacet. When an external function is called on a diamond its fallback function is executed. The fallback function finds in the selectorToFacet mapping which facet has the function that has been called and then executes that function from the facet using delegatecall.")])]),t._v(" "),a("blockquote",[a("p",[t._v("A diamond can use a "),a("code",[t._v("diamondCut")]),t._v(" function to add/replace/remove any number of functions from any number of facets in a single transaction. "),a("code",[t._v("diamondCut")]),t._v(" updates the mapping of function selector to facet address. Other such functions can be used.")])]),t._v(" "),a("p",[t._v("简单翻译")]),t._v(" "),a("blockquote",[a("p",[t._v("钻石合约存储了逻辑合约地址和方法的映射，当通过代理合约调用方法的事后，代理合约的 fallback 方法执行，具体逻辑是 fallback 会根据之前维护的映射关系去查找具体的方法对应的逻辑合约的地址，找到后通过 delegatecall 调用对应逻辑合约的方法。")])]),t._v(" "),a("blockquote",[a("p",[t._v("钻石合约使用 "),a("code",[t._v("diamondCut")]),t._v(" 合约去增加/替换/移除逻辑合约的方法（这儿有个不明白的地方是逻辑合约肯定部署好是不能改变的，我不明白什么场景会增加逻辑合约的方法，除非是刚开始不想暴露出来方法，现在想要暴露出来了），"),a("code",[t._v("diamondCut")]),t._v(" 会更新映射关系。")])]),t._v(" "),a("p",[t._v("所以整体看下来的话，钻石合约就是比普通的合约增加了一个中间的插槽层。官方的文档基本上把这些机制说的还挺明白了，我之前看别的文章都没有官方的这个解释说的明白。")]),t._v(" "),a("h3",{attrs:{id:"存储冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储冲突"}},[t._v("#")]),t._v(" 存储冲突")]),t._v(" "),a("p",[t._v("钻石合约这种设计方案是如何解决存储冲突的问题呢？钻石合约集中中，每个逻辑合约使用一个结构体进行数据存储，然后根据不同的 hash 值作为这个结构体存储的 slot，只要每个逻辑合约都使用自己的 hash 值的话，那就不会发生存储冲突的问题。")]),t._v(" "),a("div",{staticClass:"language-jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// A contract that implements Diamond Storage.")]),t._v("\nlibrary LibA "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This struct contains state variables we care about.")]),t._v("\n  struct DiamondStorage "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    address owner"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    bytes32 dataA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Returns the struct from a specified position in contract storage")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ds is short for DiamondStorage")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("diamondStorage")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" internal pure "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("returns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("DiamondStorage storage ds")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Specifies a random position in contract storage")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This can be done with a keccak256 hash of a unique string as is")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// done here or other schemes can be used such as this:")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// bytes32 storagePosition = keccak256(abi.encodePacked(ERC1155.interfaceId, ERC1155.name, address(this)));")]),t._v("\n    bytes32 storagePosition "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("keccak256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"diamond.storage.LibA"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Set the position of our struct in contract storage")]),t._v("\n    assembly "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("ds"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("slot "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" storagePosition"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("钻石合约通过对合约进行结构化设计，将合约的实现不断拓展，突破了以往传统合约的开发限制，但也增加了合约结构的复杂性。目前(2022-06-06)这个钻石合约还在审查阶段，对于钻石合约的具体实现方案，目前官方给出了"),a("a",{attrs:{href:"https://github.com/mudgen/Diamond",target:"_blank",rel:"noopener noreferrer"}},[t._v("三种实现方案"),a("OutboundLink")],1),t._v("，根据不同的场景去使用，比如有的是简化整体实现设计，有的是节省 Gas。")]),t._v(" "),a("p",[t._v("我自己的想法是，如果不是对钻石合约非常理解的话，还是慎重使用，因为相对于 Openzeppelin 提供的代理方案来说，钻石合约机制并没有提供完善的脚手架以及安全检查机制，很可能因为不小心出现的问题造成损失，相对比的话 Openzeppelin 对代理升级方案提供了完善的安全检查机制和部署脚手架，防止开发者出现不小心造成的安全漏洞。如果之后 Openzepplin 提供了对钻石合约的实现的话，我觉得那将会是比较好的时机采用钻石机制来实现我们复杂的合约机制。"),a("a",{attrs:{href:"https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2793",target:"_blank",rel:"noopener noreferrer"}},[t._v("但是 Openzeppeplin 目前并没有支持钻石合约的计划"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("参考地址:")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://eips.ethereum.org/EIPS/eip-2535",target:"_blank",rel:"noopener noreferrer"}},[t._v("EIP-2535: Diamonds, Multi-Facet Proxy"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://learnblockchain.cn/article/1398",target:"_blank",rel:"noopener noreferrer"}},[t._v("登链社区-[译]通过钻石标准解决以太坊合约大小限制"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://docs.soliditylang.org/en/v0.8.14/internals/layout_in_storage.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Solidity-Layout of State Variables in Storage"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://docs.soliditylang.org/en/v0.8.11/assembly.html#access-to-external-variables-functions-and-libraries",target:"_blank",rel:"noopener noreferrer"}},[t._v("Solidity-Access to External Variables, Functions and Libraries"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/mudgen/Diamond",target:"_blank",rel:"noopener noreferrer"}},[t._v("Github-Diamond Implementation"),a("OutboundLink")],1)])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("关注我的微信公众号，我在上面会分享我的日常所思所想。")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{attrs:{src:e(323),width:"40%/"}})])])}),[],!1,null,null,null);a.default=s.exports}}]);