(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{544:function(e,t,a){e.exports=a.p+"assets/img/Untitled_11.544ce648.png"},545:function(e,t,a){e.exports=a.p+"assets/img/Untitled.f32aef98.png"},546:function(e,t,a){e.exports=a.p+"assets/img/Untitled_1.5fa885ce.png"},547:function(e,t,a){e.exports=a.p+"assets/img/Untitled_2.029a9a73.png"},548:function(e,t,a){e.exports=a.p+"assets/img/Untitled_3.f6e24086.png"},549:function(e,t,a){e.exports=a.p+"assets/img/Untitled_4.2658a318.png"},550:function(e,t,a){e.exports=a.p+"assets/img/Untitled_5.d95cd69b.png"},551:function(e,t,a){e.exports=a.p+"assets/img/Untitled_6.87feb9a6.png"},552:function(e,t,a){e.exports=a.p+"assets/img/Untitled_7.a2212438.png"},553:function(e,t,a){e.exports=a.p+"assets/img/Untitled_8.e280ad00.png"},554:function(e,t,a){e.exports=a.p+"assets/img/Untitled_9.5150c98f.png"},555:function(e,t,a){e.exports=a.p+"assets/img/Untitled_10.9413f5a4.png"},695:function(e,t,a){"use strict";a.r(t);var n=a(5),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("本文尝试回答几个问题。")]),e._v(" "),t("ul",[t("li",[e._v("CALayer 是什么")]),e._v(" "),t("li",[e._v("drawRect 和 CALayer 的关系")]),e._v(" "),t("li",[e._v("一个视图是如何渲染到屏幕上的？")])]),e._v(" "),t("h3",{attrs:{id:"视图的基本展示单元-calayer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#视图的基本展示单元-calayer"}},[e._v("#")]),e._v(" 视图的基本展示单元 CALayer")]),e._v(" "),t("p",[e._v("我们在 iOS 日常开发用到的最常用的视图控件就是 "),t("code",[e._v("UIView")]),e._v("。大多数开发者也知道 "),t("code",[e._v("UIView")]),e._v(" 是对 "),t("code",[e._v("CALayer")]),e._v(" 的一次封装，"),t("code",[e._v("CALayer")]),e._v(" 属性才是真正的控制展示的部分。对 "),t("code",[e._v("UIView")]),e._v(" 来说，我们操作 "),t("code",[e._v("UIView")]),e._v(" 的 "),t("code",[e._v("backgroudColor")]),e._v(" 之类的属性，其实本质上是对 "),t("code",[e._v("CALayer")]),e._v(" 的操作，"),t("code",[e._v("CALayer")]),e._v(" 管理着所有可视化内容的选项。")]),e._v(" "),t("p",[t("code",[e._v("CALayer")]),e._v(" 中有一个属性是 "),t("code",[e._v("contents")]),e._v("，官方对它的解释是「An object that provides the contents of the layer. Animatable.」"),t("strong",[e._v("也就是说 "),t("code",[e._v("contents")]),e._v(" 包含着你想要呈现的内容的位图信息。")])]),e._v(" "),t("p",[e._v("但是 "),t("code",[e._v("backgroundColor")]),e._v(" 和 "),t("code",[e._v("contents")]),e._v(" 可不是一个东西，可以看"),t("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW5",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),t("OutboundLink")],1),e._v("中的 "),t("code",[e._v("CALayer")]),e._v(" 的组成图，"),t("code",[e._v("backgroundColor")]),e._v(" 是在 "),t("code",[e._v("contents")]),e._v(" 后面，"),t("code",[e._v("borderWidth")]),e._v(" 和 "),t("code",[e._v("borderColor")]),e._v(" 是在前面。")]),e._v(" "),t("p",[t("img",{attrs:{src:a(544),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("给 "),t("code",[e._v("contents")]),e._v(" 提供内容有主要有两种方式")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("如果我们只使用 "),t("code",[e._v("CALayer")]),e._v(" 去做呈现的话，可以直接给 "),t("code",[e._v("contents")]),e._v(" 提供视图内容去进行展示，比如使用如下方式可以直接设置图片")]),e._v(" "),t("div",{staticClass:"language-swift extra-class"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" layer "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("CALayer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nlayer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("contents "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("UIImage")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("init")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("named"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string-literal"}},[t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Monosnap"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("cgImage\n")])])])]),e._v(" "),t("li",[t("p",[e._v("设置 layer 的绘制代理。比如我们最常用的 "),t("code",[e._v("UIView-CALayer")]),e._v(" 这种展示方式，"),t("code",[e._v("UIView")]),e._v(" 是实现了 "),t("code",[e._v("CALayerDelegate")]),e._v(" 协议的，也是通过实现这个协议方法来给 "),t("code",[e._v("CALayer")]),e._v(" 提供展示用的内容，即提供展示信息给 "),t("code",[e._v("contents")]),e._v(" 属性。这个 "),t("code",[e._v("contents")]),e._v(" 属性被称为「寄宿图」。")])])]),e._v(" "),t("p",[e._v("我们日常最常用的就是后者，所以也将重点放在后面。")]),e._v(" "),t("h3",{attrs:{id:"uiview-的-drawrect-和-calayer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uiview-的-drawrect-和-calayer"}},[e._v("#")]),e._v(" UIView 的 drawRect 和 CALayer")]),e._v(" "),t("p",[e._v("关于 "),t("a",{attrs:{href:"https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect",target:"_blank",rel:"noopener noreferrer"}},[e._v("drawRect:"),t("OutboundLink")],1),e._v(" 它其实没有默认实现。当子类继承 "),t("code",[e._v("UIView")]),e._v(" 想要提供自己的绘制方法的时候，也不需要调用父类的绘制方法，而是"),t("strong",[e._v("自己实现 "),t("code",[e._v("drawRect:")]),e._v(" 方法，提供绘制实现，本质上就是给 "),t("code",[e._v("CALayer")]),e._v(" 的 "),t("code",[e._v("contents")]),e._v(" 提供要显示的内容。")])]),e._v(" "),t("p",[e._v("当调用 "),t("code",[e._v("drawRect:")]),e._v(" 方法的时候，UIKit 已视图配置了适当的绘图上下文，可以通过 "),t("code",[e._v("UIGraphicsGetCurrentContext")]),e._v(" 函数获取对上下文的引用，比如可以使用如下代码，在自定义子视图上画一条横线。")]),e._v(" "),t("div",{staticClass:"language-swift extra-class"},[t("pre",{pre:!0,attrs:{class:"language-swift"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("override")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("func")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function-definition function"}},[e._v("draw")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token omit keyword"}},[e._v("_")]),e._v(" rect"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("CGRect")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" context"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("CGContext")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("UIGraphicsGetCurrentContext")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    context"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("setLineWidth")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    context"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("setStrokeColor")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("UIColor")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("green"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("cgColor"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    context"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("move")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("to"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("CGPoint")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("init")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("50")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("50")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    context"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("addLine")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("to"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("CGPoint")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("init")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("100")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    context"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("strokePath")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("p",[e._v("其实系统的很多控件也是通过 "),t("code",[e._v("drawRect:")]),e._v(" 方法来实现绘制的，比如 "),t("code",[e._v("UILabel")]),e._v("，尽管没有反编译 "),t("code",[e._v("UIKit")]),e._v(" 的代码，但是通过继承 "),t("code",[e._v("UILabel")]),e._v(" 得到子视图，实现一个空的 "),t("code",[e._v("drawRect:")]),e._v(" 方法，"),t("code",[e._v("UILabel")]),e._v(" 就不会再正常展示文字了，所以可以推断原始的 "),t("code",[e._v("UILabel")]),e._v(" "),t("code",[e._v("drawRect:")]),e._v(" 方法中有对应文字绘制的实现。")]),e._v(" "),t("p",[e._v("关于 "),t("code",[e._v("drawRect:")]),e._v(" 引起内存「暴涨」的说法，很多是源于这篇「"),t("a",{attrs:{href:"https://bihongbo.com/2016/01/03/memoryGhostdrawRect/",target:"_blank",rel:"noopener noreferrer"}},[e._v("内存恶鬼drawRect"),t("OutboundLink")],1),e._v("」的讨论。我自己的看法是，是当 "),t("code",[e._v("UIView")]),e._v(" 识别到 "),t("code",[e._v("drawRect:")]),e._v(" 存在的时候，系统确实会分配一片内存用来进行绘制，这块儿内存的大小就是视图大小乘以 "),t("code",[e._v("contentsScale")]),e._v(" ，所以如果我们的视图不需要定制绘制的时候，就没必要再图层子类里面保留空的 "),t("code",[e._v("drawRect:")]),e._v(" 方法，白白让系统浪费内存。但确实需要定制绘制的情况下，当然可以实现 "),t("code",[e._v("drawRect:")]),e._v(" 进行绘制。毕竟刚才也说了，很多系统控件也是通过 "),t("code",[e._v("drawRect:")]),e._v(" 来进行绘制的。同时应该注意绘制的 CoreGraphics 是使用 CPU 资源进行图像绘制的，所以绘制过程应该尽量不要太重，否则可能会导致主线程的卡顿（参考 "),t("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/ImprovingAnimationPerformance/ImprovingAnimationPerformance.html#//apple_ref/doc/uid/TP40004514-CH9-SW1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Use Asynchronous Layer Rendering As Needed"),t("OutboundLink")],1),e._v("）。")]),e._v(" "),t("p",[t("code",[e._v("drawRect:")]),e._v(" 方法是使用 CoreGraphics 进行的图像绘制，当我们在 "),t("code",[e._v("drawRect:")]),e._v(" 方法里打断点的时候会看到如下调用栈：")]),e._v(" "),t("blockquote",[t("p",[e._v("PS: "),t("a",{attrs:{href:"https://developer.apple.com/documentation/coregraphics",target:"_blank",rel:"noopener noreferrer"}},[e._v("Core Graphics"),t("OutboundLink")],1),e._v(" 框架是基于 Quartz2D 绘图引擎的。")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(545),alt:"Untitled"}})]),e._v(" "),t("p",[t("strong",[e._v("尝试分析一下这个调用栈来思考 "),t("code",[e._v("drawRect:")]),e._v(" 绘制的内容是如何给到 "),t("code",[e._v("CALayer'contents")]),e._v(" 属性的。")])]),e._v(" "),t("p",[e._v("Runloop 区域就先不分析了，"),t("code",[e._v("CA::Transaction::commit()")]),e._v(" 中关键 API 是 "),t("code",[e._v("CATransaction")]),e._v("。")]),e._v(" "),t("blockquote",[t("p",[e._v("CATransaction 是 Core Animation 中的事务类，负责批量的把多个对图层树(layer-tree)的修改作为一个原子更新到渲染树。")])]),e._v(" "),t("p",[e._v("这里也暂时先略过，然后我们看到 "),t("code",[e._v("CALayer")]),e._v(" 的 "),t("code",[e._v("display")]),e._v(" 方法，官方说明是刷新 "),t("code",[e._v("layer.contents")]),e._v(" 的内容。这个方法的"),t("a",{attrs:{href:"https://developer.apple.com/documentation/quartzcore/calayer/1410926-display",target:"_blank",rel:"noopener noreferrer"}},[e._v("说明"),t("OutboundLink")],1),e._v("有点意思")]),e._v(" "),t("ul",[t("li",[e._v("如果代理对象(即UIView)实现了 "),t("code",[e._v("CALayerDelegate")]),e._v(" 协议中 "),t("code",[e._v("display(_ layer:)")]),e._v(" 方法的话，则会调用此方法，让代理对象直接更新 layer.contents 属性，")]),e._v(" "),t("li",[e._v("如果代理对象没有实现这个方法的话，则 display 会创建一个后备存储区域(backing store) ，同时触发 "),t("code",[e._v("CALayerDelegate")]),e._v(" 协议的另外  "),t("code",[e._v("-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;")]),e._v(" 方法调用。")])]),e._v(" "),t("p",[e._v("我自己理解 UIView 是实现了后面的协议方法，这里的后备存储其实就是 "),t("code",[e._v("CGContext")]),e._v(" 管理的， "),t("code",[e._v("drawLayer:inContext:")]),e._v("  API 也把 "),t("code",[e._v("CGContext")]),e._v(" 作为参数，通知 UIView 使用实现绘制流程，在后备存储上绘制完成之后，使用后备存储作为 CALayer 的 contents 属性内容。")]),e._v(" "),t("p",[t("strong",[e._v("我自己理解 "),t("code",[e._v("CALayer")]),e._v(" 作为 CoreAnimation 框架中最重要的类，其实就是连接 UIView 和 CoreGraphics 的桥梁。")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(546),alt:"Untitled"}})]),e._v(" "),t("h3",{attrs:{id:"视图是如何渲染到屏幕上的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#视图是如何渲染到屏幕上的"}},[e._v("#")]),e._v(" 视图是如何渲染到屏幕上的")]),e._v(" "),t("p",[e._v("下图简要的描述了计算机渲染的流程")]),e._v(" "),t("p",[t("img",{attrs:{src:a(547),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("但是具体 iOS 里是什么样子呢？GPU 和 CoreAnimation 框架是如何协作的？总的流程大概是下面这个样子，来自 "),t("a",{attrs:{href:"https://www.bilibili.com/video/BV15q4y177xb/?vd_source=06c3d20715183a10b894274ffd31554c",target:"_blank",rel:"noopener noreferrer"}},[e._v("WWDC14：Advanced Graphics and Animations for iOS Apps"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("img",{attrs:{src:a(548),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("下面这张图是最新的 "),t("a",{attrs:{href:"https://developer.apple.com/videos/play/tech-talks/10855/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Video-Explore UI animation hitches and the render loop"),t("OutboundLink")],1),e._v(" 官方视频的介绍，配合看可能会更好看一点。")]),e._v(" "),t("p",[t("img",{attrs:{src:a(549),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("渲染循环有 5 个阶段")]),e._v(" "),t("ol",[t("li",[e._v("循环从第一阶段（事件阶段）开始。在这里，您的应用程序处理触摸事件并决定是否需要在 UI 中进行更改。接下来是提交阶段。")]),e._v(" "),t("li",[t("strong",[e._v("在提交阶段，您的应用程序更新其 UI 并将其提交到渲染服务器进行渲染。")])]),e._v(" "),t("li",[e._v("在下一个 VSYNC 上，渲染服务器接受该提交，并在渲染准备阶段准备在 GPU 上进行绘制。")]),e._v(" "),t("li",[e._v("在渲染执行阶段，GPU 将您的 UI 绘制为最终图像。")]),e._v(" "),t("li",[e._v("再下一个 VSYNC 时，可以将帧显示给您的用户。")])]),e._v(" "),t("p",[e._v("我们着重介绍提交阶段的内容，参考 WWDC 2014 -Advanced Graphics and Animations for iOS Apps，提交阶段又分为四个部分")]),e._v(" "),t("ul",[t("li",[e._v("1️⃣ Layout - Set up the views")]),e._v(" "),t("li",[e._v("2️⃣ Display - Draw the views")]),e._v(" "),t("li",[e._v("3️⃣ Prepare - Additional Core Animation work")]),e._v(" "),t("li",[e._v("4️⃣ Commit - Package up layers and send them to render server")])]),e._v(" "),t("blockquote",[t("p",[e._v("PS: 这篇 WWDC 视频已经下架了，英文字幕在"),t("a",{attrs:{href:"https://asciiwwdc.com/2014/sessions/419",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),t("OutboundLink")],1),e._v("。")])]),e._v(" "),t("p",[e._v("详细说明一下提交阶段的这四个部分")]),e._v(" "),t("ol",[t("li",[t("p",[t("strong",[e._v("Layout - Set up the views")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(550),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("我觉得这张图容易让人歧义，好像视图创建的过程发生在视图布局之后，怎么会这样？这俩顺序颠倒一下是不是比较好。这部分是发生在 CPU 创建过程。")]),e._v(" "),t("blockquote",[t("p",[e._v("In the Layout phase the layoutSubviews overrides are invoked. This is where view creation happens. This is where we add layers to the view hierarchy with addSubview and this is where populate content and do some lightweight database lookups.")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Display - Draw the views")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(551),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("这阶段主要就是 drawRect: 在发挥作用了，而且我们之前也说过 drawRect: 主要是通过 CGContext 进行绘制，最终将绘制结果存储在一片通过 CALayer.contents 维护的内存里。这部分也是在占用 CPU 资源。")]),e._v(" "),t("blockquote",[t("p",[e._v("This is where the draw contents this drawRect if it’s overridden or do string drawing.\nOne thing worth noting here is that this phase is actually CPU or memory bound, because the rendering is [inaudible]. We use here the core graphics for this rendering.\nAnd so we usually do this rendering with CG context.")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Prepare - Additional Core Animation work")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(552),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("我理解这步骤除非是类似 UIImageView 这样的控件或者 CALayer.contents 属性直接指向了图片内容，否则一般的控件用不到图片解码。这步骤依然发生在 CPU 层面，原因是有的图片格式 GPU 不支持。")]),e._v(" "),t("blockquote",[t("p",[e._v("This is where image decoding and image conversion happens. This happens if you have any images and in your view hierarchy and these JPEGs or PNGs are getting decoded at this point. "),t("strong",[e._v("What happens here is that we might have images that are not supported by the GPU.")])])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Commit - Package up layers and send them to render server")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(553),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("打包 layer 的内容然后发送给渲染服务。但是我很好奇这个打包过程是怎么发生的？理论上到这一步既然是递归打包，说明视图层级树上的所有视图都已经绘制完毕了。")]),e._v(" "),t("blockquote",[t("p",[e._v("In the last phase the Commit phase, we package up the layers and send them to the render server. This process is recursive. You have to reiterate over the whole layer tree and this is expensive.")])])])]),e._v(" "),t("p",[e._v("跟我们日常应用密切相关的其实就是提交部分，CoreAnimation 框架负责了上述的提交流程，包括视图布局调用时机，以及控制 "),t("code",[e._v("drawRect")]),e._v(" 绘制时机实际等等。")]),e._v(" "),t("p",[e._v("CoreAnimation 是如何知道这些调用时机的呢？这里就用到了 Runloop 相关的概念了。YY 大神在文章里是这么写的")]),e._v(" "),t("p",[t("em",[e._v("当在操作 UI 时，比如改变了 "),t("code",[e._v("Frame")]),e._v("、更新了 "),t("code",[e._v("UIView/CALayer")]),e._v(" 的层次时，或者手动调用了 "),t("code",[e._v("UIView/CALayer")]),e._v(" 的 "),t("code",[e._v("setNeedsLayout/setNeedsDisplay")]),e._v("方法后，这个 "),t("code",[e._v("UIView/CALayer")]),e._v(" 就被标记为待处理，并被提交到一个全局的容器去。")])]),e._v(" "),t("p",[t("em",[e._v("苹果注册了一个 "),t("code",[e._v("Observer")]),e._v(" 监听 "),t("code",[e._v("BeforeWaiting")]),e._v("(即将进入休眠) 和 "),t("code",[e._v("Exit")]),e._v(" (即将退出Loop) 事件，回调去执行一个很长的函数：\n"),t("code",[e._v("_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()")]),e._v("。这个函数里会遍历所有待处理的 "),t("code",[e._v("UIView/CAlayer")]),e._v(" 以执行实际的绘制和调整，并更新 UI 界面。")])]),e._v(" "),t("p",[e._v("我自己理解，应该就是 "),t("code",[e._v("CoreAnimation")]),e._v(" 注册了两个 "),t("code",[e._v("Runloop")]),e._v(" 的时机去做了对应的绘图和调整。当然官方说的很隐晦：")]),e._v(" "),t("blockquote",[t("p",[e._v("CATransaction 关于隐式提交的说明如下\nImplicit transactions are created automatically when the layer tree is modified by a thread without an active transaction and are committed automatically when the thread's runloop next iterates.")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(554),alt:"Untitled"}})]),e._v(" "),t("p",[t("strong",[e._v("我感觉 CA:Transaction:commit 这个过程就是对应上面提交阶段。")])]),e._v(" "),t("p",[e._v("CoreAnimation 这个框架其实就是为上层 UIKit 创造了绘图的环境。UIKit 只管发命令，CoreGraphics 只管绘制，CoreAnimation 会负责协调绘制和更新过程。")]),e._v(" "),t("p",[e._v("CoreAnimation 最终发给渲染服务器的是它维护的图层树，渲染服务器会将图层树转换为实际的可显示图像。我自己感觉OpenGL 是将图层内容翻译为了 GPU 能识别的格式放到 Buffer 里面。")]),e._v(" "),t("p",[e._v("所以总结一下，视图层是如何渲染到屏幕上的，就是视图初始化填充完数据并布局完子视图之后，开启绘制，本质上是给 "),t("code",[e._v("CALayer")]),e._v(" 的 "),t("code",[e._v("contents")]),e._v("  属性提供渲染内容，最后 CoreAnimation 将图层树打包发给渲染服务器，渲染服务器利用 OpenGL 提供的通道向 GPU 发送渲染指令。最终 GPU 完成渲染，将渲染结果发给帧缓冲器，随着垂直同步信号的到来，显示器从帧缓冲器中读取到图像，展示到屏幕上。")]),e._v(" "),t("blockquote",[t("p",[e._v("OpenGL 不太熟悉，渲染服务器的线性管道这部分知识盲区，不太明白 GPU 管道的含义，暂放一下。下图是一个渲染流程，浅贴一下， GPU 那块儿真的不熟…")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(555),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("以上如果有理解的不对的地方，欢迎指出来，有疑问也可以一起讨论一下")]),e._v(" "),t("p",[e._v("参考地址:")]),e._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/157708445",target:"_blank",rel:"noopener noreferrer"}},[e._v("离屏渲染"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ibireme-iOS 保持界面流畅的技巧"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.bilibili.com/video/BV15q4y177xb/?vd_source=06c3d20715183a10b894274ffd31554c",target:"_blank",rel:"noopener noreferrer"}},[e._v("WWDC14：Advanced Graphics and Animations for iOS Apps"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Core Animation Programming Guide"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-SW9",target:"_blank",rel:"noopener noreferrer"}},[e._v("Quartz 2D Programming Guide"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://gist.github.com/leasual/f15ad84c4de541f12865d0d1b1bd3b0e",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS Core Animation: Advanced Techniques, Part 1: The Layer Beneath"),t("OutboundLink")],1),e._v("  #drawRect: 分配内存图说明")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://tenloy.github.io/2021/09/09/core-animation02.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Core Animation(二) - 隐式动画、CATransaction与CAAction"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/documentation/quartzcore/calayer/1410926-display",target:"_blank",rel:"noopener noreferrer"}},[e._v("CALayer display API"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://objccn.io/issue-3-1/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ObjcIO-绘制像素到屏幕上"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/videos/play/tech-talks/10855/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Video-Explore UI animation hitches and the render loop"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://joakimliu.github.io/2019/03/02/wwdc-2014-419/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Advanced Graphics and Animations for iOS Apps"),t("OutboundLink")],1)])]),e._v(" "),t("Vssue",{attrs:{title:"2024-02-29-聊聊iOS渲染"}})],1)}),[],!1,null,null,null);t.default=r.exports}}]);