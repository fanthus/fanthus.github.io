(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{359:function(e,o,t){e.exports=t.p+"assets/img/Jietu20180305-184629.fe8c5a9b.png"},360:function(e,o,t){e.exports=t.p+"assets/img/15203089948766.7b7bddcc.jpg"},596:function(e,o,t){"use strict";t.r(o);var n=t(5),r=Object(n.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[o("code",[e._v("Objective-C")]),e._v(" 语言里的拷贝就是对象拷贝，即创建一个跟之前的实例对象一模一样的对象。一般来说数据模型类是需要支持拷贝的。"),o("code",[e._v("Objective-C")]),e._v(" 里拷贝又分为浅拷贝（"),o("code",[e._v("shallow-copy")]),e._v("）和深拷贝（"),o("code",[e._v("deep-copy")]),e._v("）。")]),e._v(" "),o("h1",{attrs:{id:"浅拷贝和深拷贝区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝和深拷贝区别"}},[e._v("#")]),e._v(" 浅拷贝和深拷贝区别")]),e._v(" "),o("p",[e._v("浅拷贝只是复制一下对象指针，但是拷贝前和拷贝后的对象指针均指向同一内存区域，只不过是对象的内存引用计数加一。\n深拷贝为拷贝前和拷贝后的对象指针指向不同的内存区域，即会创建一个新的对象。\n下图比较直观清楚。\n"),o("img",{attrs:{src:t(359),alt:"Jietu20180305-184629"}})]),e._v(" "),o("p",[e._v("一个非常容易产生的误区就是，遵从了 "),o("code",[e._v("NSCopying")]),e._v(" 协议的对象都会执行深拷贝。其实不然，"),o("code",[e._v("Foundation")]),e._v(" 框架里大部分类执行的还是浅拷贝。比如 "),o("code",[e._v("NSString")]),e._v(" 等。举个例子：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('NSString *str = [NSString stringWithFormat:@"%@",@"hello"];\nNSString *copyStr = [str copy];\nNSLog(@"str = %p,copyStr = %p",str ,copyStr);\n---\n> str = 0x6f6c6c656855,copyStr = 0x6f6c6c656855\n> str 在 copy 前后指向的内存地址都一模一样。\n')])])]),o("p",[e._v("还有一点注意的是，虽然有浅拷贝和深拷贝的概念，"),o("strong",[e._v("但是并没有专门定义深拷贝的协议")]),e._v("。这点很关键，这意味着除非有文档是写用深拷贝实现 "),o("code",[e._v("NSCopying")]),e._v(" 协议的，否则深拷贝的实现都是需要开发者自己去手写实现，而不能依赖于系统框架的实现。")]),e._v(" "),o("h1",{attrs:{id:"copy-实例方法和-nscopying-协议"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copy-实例方法和-nscopying-协议"}},[e._v("#")]),e._v(" Copy 实例方法和 NSCopying 协议")]),e._v(" "),o("p",[o("code",[e._v("NSObject")]),e._v(" 有名为 "),o("code",[e._v("copy")]),e._v(" 和 "),o("code",[e._v("mutableCopy")]),e._v(" 的实例方法。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("- (id)copy;\n- (id)mutableCopy;\n")])])]),o("p",[o("code",[e._v("NSCopying")]),e._v(" 协议的方法为 "),o("code",[e._v("-(id)copyWithZone:(nullable NSZone *)zone")]),e._v("。（"),o("code",[e._v("zone")]),e._v(" 目前没有任何意义）")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("@protocol NSCopying\n- (id)copyWithZone:(nullable NSZone *)zone;\n@end\n")])])]),o("p",[e._v("这个实例方法和协议方法有啥关联呢？其实调用 "),o("code",[e._v("NSObject")]),e._v(" 的 "),o("code",[e._v("copy")]),e._v(" 实例方法就是调用 "),o("code",[e._v("NSCopying")]),e._v(" 协议约定的 "),o("code",[e._v("copyWithZone")]),e._v(" 方法。同理的，调用 "),o("code",[e._v("NSObject")]),e._v(" 的 "),o("code",[e._v("mutableCopy")]),e._v(" 实例方法就是调用 "),o("code",[e._v("NSMutableCopying")]),e._v(" 协议的 "),o("code",[e._v("mutableCopyWithZone")]),e._v(" 方法。")]),e._v(" "),o("p",[e._v("需要注意的是，因为 "),o("code",[e._v("NSObject")]),e._v(" 类并不支持 "),o("code",[e._v("NSCopying")]),e._v(" 协议，所以继承 "),o("code",[e._v("NSObject")]),e._v(" 的子类如果不实现 "),o("code",[e._v("NSCopying")]),e._v(" 协议的 "),o("code",[e._v("copyWithZone")]),e._v(" 方法会导致应用异常。 见下面 "),o("code",[e._v("demo")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("@interface FRModel : NSObject\n@end\n@implementation FRModel\n@end\n---\nFRModel *model = [[FRModel alloc] init];\n[model copy];\n> -[FRModel copyWithZone:]: unrecognized selector sent to instance 0x1004004c0\n")])])]),o("blockquote",[o("p",[o("code",[e._v("copy")]),e._v(" "),o("a",{attrs:{href:"https://developer.apple.com/documentation/objectivec/nsobject/1418807-copy?language=objc#",target:"_blank",rel:"noopener noreferrer"}},[e._v("API 说明"),o("OutboundLink")],1),e._v("\nReturns the object returned by copyWithZone:.")])]),e._v(" "),o("p",[e._v("因为 "),o("code",[e._v("NSObject")]),e._v(" 并没有实现 "),o("code",[e._v("NSCopying")]),e._v(" 协议，即没有实现 "),o("code",[e._v("copyWithZone:")]),e._v(" 方法，所以 "),o("code",[e._v("FRModel")]),e._v(" 需要单独实现 "),o("code",[e._v("copyWithZone:")]),e._v(" 方法。有一个误区是子类直接复写 "),o("code",[e._v("copy")]),e._v(" 方法，这是不正确的操作方式，要避免。")]),e._v(" "),o("h1",{attrs:{id:"copy-和-mutablecopy"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copy-和-mutablecopy"}},[e._v("#")]),e._v(" Copy 和 MutableCopy")]),e._v(" "),o("p",[e._v("上面说了 "),o("code",[e._v("NSObject")]),e._v(" 有 "),o("code",[e._v("copy")]),e._v(" 和 "),o("code",[e._v("mutableCopy")]),e._v(" 两个实例方法。对应的也有两个协议， "),o("code",[e._v("NSCopying(copyWithZone:)")]),e._v(" 和 "),o("code",[e._v("NSMutableCopying(mutableCopyWithZone:)")]),e._v("。虽然名字比较像但是这是两个不同的类，即如果你的类只实现了 "),o("code",[e._v("NSCopying")]),e._v(" 协议，这时候给你发 "),o("code",[e._v("mutableCopy")]),e._v(" 方法的话还是照样会异常，这两个也没有任何包含关系，把这两个类理解为单独的协议就好了。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('FRModel *model = [[FRModel alloc] init];\nmodel.name = @"Frank";\nFRModel *copyModel = [model mutableCopy];\nNSLog(@"model = %p,copymodel = %p",model,copyModel);\nNSLog(@"model.name = %p,copymodel.name = %p",model.name,copyModel.name);\n---\n> FRCopyDemo *** Terminating app due to uncaught exception \'NSInvalidArgumentException\', reason: \'-[FRModel mutableCopyWithZone:]: unrecognized selector sent to instance 0x100532040\'\n')])])]),o("h2",{attrs:{id:"什么时候用-copy-什么时候用-mutablecopy"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么时候用-copy-什么时候用-mutablecopy"}},[e._v("#")]),e._v(" 什么时候用 Copy 什么时候用 MutableCopy?")]),e._v(" "),o("p",[e._v("我们可以看下 "),o("code",[e._v("NSMutableCopying")]),e._v(" 的"),o("a",{attrs:{href:"https://developer.apple.com/documentation/foundation/nsmutablecopying?language=objc",target:"_blank",rel:"noopener noreferrer"}},[e._v("协议说明"),o("OutboundLink")],1)]),e._v(" "),o("blockquote",[o("p",[e._v("The "),o("code",[e._v("NSMutableCopying")]),e._v(" protocol declares a method for providing mutable copies of an object.\nOnly classes that define an “immutable vs. mutable” distinction should adopt this protocol. Classes that don’t define such a distinction should adopt "),o("code",[e._v("NSCopying")]),e._v(" instead.\n"),o("code",[e._v("NSMutableCopying")]),e._v(" 声明了提供可对象可变副本的方法，只有区分可变和不可变的类应该遵守这个协议，不区分可变不尅版的话就直接用 NSCopying 方法就好了。")])]),e._v(" "),o("p",[e._v("举个例子，我们日常使用的包括可变类型的类是 "),o("code",[e._v("NSString(NSMutableString)")]),e._v("，"),o("code",[e._v("NSArray(NSMutableArray)")]),e._v("，"),o("code",[e._v("NSDictionary(NSMutableDictionary)")]),e._v("以及"),o("code",[e._v("NSSet(NSMutableSet)")]),e._v(" 这些类都是同时遵守了 "),o("code",[e._v("NSCopying")]),e._v(" 和 "),o("code",[e._v("NSMutableCopying")]),e._v(" 协议的。一般来说，我们自己用到的类很少有是可变类型的，所以也很少看到有自己的类实现 "),o("code",[e._v("NSMutableCopying")]),e._v(" 协议。")]),e._v(" "),o("p",[e._v("如果要实现的话基本遵守如下原则：")]),e._v(" "),o("ol",[o("li",[e._v("向可变("),o("code",[e._v("mutable")]),e._v(")或者不可变("),o("code",[e._v("immutable")]),e._v(")对象发送 "),o("code",[e._v("copy")]),e._v(" 消息，得到的都是不可变("),o("code",[e._v("immutable")]),e._v(")对象。")]),e._v(" "),o("li",[e._v("向可变("),o("code",[e._v("mutable")]),e._v(")或者不可变("),o("code",[e._v("immutable")]),e._v(")对象发送 "),o("code",[e._v("mutableCopy")]),e._v(" 消息，得到的都是可变("),o("code",[e._v("mutable")]),e._v(")对象。\n举个例子验证一下")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('NSString *str = [NSString stringWithFormat:@"%@",@"hello"];\nNSMutableString *copyStr = [str mutableCopy]; //得到可变对象.\n[copyStr appendString:@" world"];\nNSLog(@"str = %p,copyStr = %p",str ,copyStr);\nNSLog(@"str class = %@,copyStr class = %@",NSStringFromClass([str class]) ,NSStringFromClass([copyStr class]));\nNSLog(@"str = %@,copyStr = %@",str ,copyStr);\n---\n> FRCopyDemo str = 0x6f6c6c656855, copyStr = 0x10044a960\n> FRCopyDemo str class = NSTaggedPointerString, copyStr class = __NSCFString\n> FRCopyDemo str = hello, copyStr = hello world\n')])])]),o("p",[e._v("通过输出结果基本上验证了以上的结论。\n这儿还有一点比较有意思的事儿是，关于 "),o("code",[e._v("mutableCopy")]),e._v(" 和深拷贝的关系。我们看到 "),o("code",[e._v("mutableCopy")]),e._v(" 之后对象的指针发生了变化，内容并没有发生变化。但其实对象指针类型已经发生了变化。所以跟我们之前说的拷贝多少还是有区别的（正常的拷贝指针类型是不会发生变化的）。只要搞清楚这些不同的概念，就能理解这些概念的区别所在。")]),e._v(" "),o("h1",{attrs:{id:"怎样让我们的对象支持-copy"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#怎样让我们的对象支持-copy"}},[e._v("#")]),e._v(" 怎样让我们的对象支持 copy")]),e._v(" "),o("p",[e._v("完整的回答应该是：让类实现 "),o("code",[e._v("NSCopying")]),e._v(" 协议里的 "),o("code",[e._v("copyWithZone")]),e._v(": 方法，如果对象是可变的应该同时实现 "),o("code",[e._v("NSMutableCopying")]),e._v(" 的 "),o("code",[e._v("mutableCopyWithZone:")]),e._v(" 方法。")]),e._v(" "),o("h1",{attrs:{id:"copywithzone-方法的最佳实践"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copywithzone-方法的最佳实践"}},[e._v("#")]),e._v(" copyWithZone: 方法的最佳实践")]),e._v(" "),o("p",[e._v("一般开发者自己实现 "),o("code",[e._v("copyWithZone:")]),e._v(" 方法的时候通常都是实现深拷贝，而非浅拷贝。因为浅拷贝确实没啥好实现的。深拷贝的实现需要考虑其父类是否也遵守了 "),o("code",[e._v("NSCopying")]),e._v(" 协议，实现了 "),o("code",[e._v("copyWithZone:")]),e._v(" 方法。\n比如继承自 "),o("code",[e._v("NSObject")]),e._v(" 的 "),o("code",[e._v("FRModel")]),e._v(" 类按如下方式实现 "),o("code",[e._v("copyWithZone:")]),e._v(" 方法，这样显然是会异常的（实际上连编译都不会编译过去）。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("@interface FRModel : NSObject<NSCopying>\n@end\n@implementation FRModel\n- (id)copyWithZone:(NSZone *)zone {\n    FRModel *frmodel = [[super allocWithZone:zone] init];\n    return frmodel;\n}\n@end\n")])])]),o("p",[e._v("稍作修改，如果父类没有实现的话子类直接重新创建一个就好了")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("@interface FRModel : NSObject<NSCopying>\n@end\n@implementation FRModel\n- (id)copyWithZone:(NSZone *)zone {\n    FRModel *frmodel = [[[self class] allocWithZone:zone] init];\n    return frmodel;\n}\n@end\n")])])]),o("p",[e._v("如果该类还有属性或者成员变量的话，可以直接对成员变量执行 "),o("code",[e._v("copy")]),e._v(" 操作。参考如下 demo:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('@interface FRModel : NSObject<NSCopying>\n@property (nonatomic,strong) NSString *name;\n@end\n@implementation FRModel\n- (id)copyWithZone:(NSZone *)zone {\n    FRModel *frmodel = [[FRModel allocWithZone:zone] init];\n    if (frmodel) { frmodel.name = [_name copyWithZone:zone]; }\n    return frmodel;\n}\n@end\n\nFRModel *model = [[FRModel alloc] init];\nmodel.name = @"Frank";\nFRModel *copyModel = [model copy];\nNSLog(@"model = %p,copymodel = %p",model,copyModel);\nNSLog(@"model.name = %p,copymodel.name = %p",model.name,copyModel.name);\n---\n> FRCopyDemo model = 0x102803520,copymodel = 0x102803530\n> FRCopyDemo model.name = 0x1000010d0,copymodel.name = 0x1000010d0\n')])])]),o("p",[e._v("注意因为 "),o("code",[e._v("NSString")]),e._v(" 类型本身 "),o("code",[e._v("copyWithZone:")]),e._v(" 属性为浅拷贝，所以最后输出结果两个类的 "),o("code",[e._v("name")]),e._v(" 属性的指针指向相同。")]),e._v(" "),o("p",[o("a",{attrs:{href:"https://stackoverflow.com/questions/9907154/best-practice-when-implementing-copywithzone",target:"_blank",rel:"noopener noreferrer"}},[e._v("Best practice when implementing copywithzone"),o("OutboundLink")],1)]),e._v(" "),o("h1",{attrs:{id:"集合类型拷贝"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#集合类型拷贝"}},[e._v("#")]),e._v(" 集合类型拷贝")]),e._v(" "),o("p",[o("code",[e._v("Foundation")]),e._v(" 框架中所有集合类型在默认情况下都执行浅拷贝，也就是说，只拷贝容器对象本身，而不复制其中数据。这样做的原因在于，容器内的对象未必能拷贝，而且调用者也未必想在拷贝容器时一并拷贝其中每一个对象。")]),e._v(" "),o("p",[e._v("集合类型的浅拷贝和深拷贝的概念和普通对象的深浅拷贝略有不同。")]),e._v(" "),o("ol",[o("li",[e._v("集合类型的浅拷贝是指，当执行浅拷贝的时候，原始集合类型里的对象都收到一个 "),o("code",[e._v("retain")]),e._v(" 消息，对象指针被复制到新的集合类型里。")]),e._v(" "),o("li",[e._v("集合类型的深拷贝是指，当执行深拷贝的时候，原始集合里的对象都会收到一个 "),o("code",[e._v("copyWithZone:")]),e._v("，即集合里的对象需要实现 "),o("code",[e._v("NSCopying")]),e._v(" 协议来实现深拷贝。如果集合里的对象并没有实现 "),o("code",[e._v("NSCopying")]),e._v(" 则程序会异常。\n如图所示\n"),o("img",{attrs:{src:t(360),alt:"15203089948766"}}),e._v("\n浅拷贝 demo:")])]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('NSObject *obj = [[NSObject alloc] init];\nNSArray *arr = [NSArray arrayWithObject:obj];\nNSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:NO];\nNSLog(@"arr = %p,copyArr = %p",arr ,copyArr);\nNSLog(@"arr model = %p,copyArr model = %p",[arr objectAtIndex:0],[copyArr objectAtIndex:0]);\n---\n> FRCopyDemo arr = 0x100462b40,copyArr = 0x100461400\n> FRCopyDemo arr model = 0x100400640,copyArr model = 0x100400640\n')])])]),o("p",[e._v("里面使用了 "),o("code",[e._v("initWithArray:copyItems:")]),e._v(" 这个方法，传入 NO 即为浅拷贝。通过打印日志可以看到集合对象指针虽然发生了变化，但是集合内部元素的对象指针还是指向同样的内存区域。")]),e._v(" "),o("p",[e._v("深拷贝 demo: (将 "),o("code",[e._v("initWithArray:copyItems:")]),e._v(" 方法第二个参数传入 YES 即为深拷贝)")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("NSObject *obj = [[NSObject alloc] init];\nNSArray *arr = [NSArray arrayWithObject:obj];\nNSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:YES];\nNSLog(@\"arr = %p,copyArr = %p\",arr ,copyArr);\nNSLog(@\"arr model = %p,copyArr model = %p\",[arr objectAtIndex:0],[copyArr objectAtIndex:0]);\n---\n> FRCopyDemo -[NSObject copyWithZone:]: unrecognized selector sent to instance 0x100688490\n> FRCopyDemo *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[NSObject copyWithZone:]: unrecognized selector sent to instance 0x100688490'\n")])])]),o("p",[e._v("因为 "),o("code",[e._v("NSObject")]),e._v(" 没有实现 "),o("code",[e._v("NSCopying")]),e._v(" 协议，所以集合类型深拷贝时，集合元素 "),o("code",[e._v("NSObject")]),e._v(" 对象收到 "),o("code",[e._v("copyWithZone:")]),e._v(" 之后异常了。我们将 NSObject 类型修改为 "),o("code",[e._v("NSMutableString")]),e._v(" 再次运行")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('NSMutableString *obj = [NSMutableString stringWithFormat:@"hello world"];\nNSArray *arr = [NSArray arrayWithObject:obj];\nNSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:YES];\nNSLog(@"arr = %p,copyArr = %p",arr ,copyArr);\nNSLog(@"arr model = %p,copyArr model = %p",[arr objectAtIndex:0],[copyArr objectAtIndex:0]);\n---\n> FRCopyDemo arr = 0x100406dc0,copyArr = 0x100403fb0\n> FRCopyDemo arr model = 0x100406780,copyArr model = 0x100405260\n')])])]),o("p",[e._v("可以看到集合内的元素执行了不同的内存地址，因为 "),o("code",[e._v("NSMutableString")]),e._v(" 收到 "),o("code",[e._v("copyWithZone:")]),e._v(" 消息会生成一个不可变的 "),o("code",[e._v("NSString")]),e._v(" 对象。\n"),o("code",[e._v("initWithArray:copyItems:")]),e._v(" "),o("a",{attrs:{href:"https://developer.apple.com/documentation/foundation/nsarray/1408557-initwitharray?language=objc#",target:"_blank",rel:"noopener noreferrer"}},[e._v("API 说明"),o("OutboundLink")],1)]),e._v(" "),o("blockquote",[o("p",[o("code",[e._v("copyItems:")]),e._v(" 参数 "),o("code",[e._v("flag")]),e._v("\nIf "),o("code",[e._v("YES")]),e._v(", each object in array receives a "),o("code",[e._v("copyWithZone:")]),e._v(" message to create a copy of the object—objects must conform to the "),o("code",[e._v("NSCopying")]),e._v(" protocol. In a managed memory environment, this is instead of the retain message the object would otherwise receive. The object copy is then added to the returned array.\nIf "),o("code",[e._v("NO")]),e._v(", then in a managed memory environment each object in array simply receives a "),o("code",[e._v("retain")]),e._v(" message when it is added to the returned array.")])]),e._v(" "),o("h2",{attrs:{id:"单层复制和完全复制"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#单层复制和完全复制"}},[e._v("#")]),e._v(" 单层复制和完全复制？")]),e._v(" "),o("p",[e._v("思考这样一种情况，即数组套数组，这种深拷贝是怎么做？\n我们刚使用 "),o("code",[e._v("initWithArray:copyItems:")]),e._v(" 方法进行的拷贝只是元素拷贝。即如果是两层数组的话，内层数组里的元素其实并没有机会执行 "),o("code",[e._v("copyWithZone:")]),e._v(" 方法。苹果官方称这种拷贝为 "),o("code",[e._v("one-level-deep copy")]),e._v("，即单层复制。")]),e._v(" "),o("p",[e._v("完全复制是指，不管嵌套多少层集合，每层的的元素都有机会执行 "),o("code",[e._v("copyWithZone:")]),e._v(" 方法。")]),e._v(" "),o("h1",{attrs:{id:"copy-和-nscoding"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copy-和-nscoding"}},[e._v("#")]),e._v(" Copy 和 NSCoding")]),e._v(" "),o("p",[e._v("如何实现完全复制呢？\n让对象实现 "),o("code",[e._v("NSCoding")]),e._v(" 协议，然后将对象归档到文件里再从文件中归档出来，即需要进行两次 I/O 操作。\n举个例子：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('//NSArray 和 NSString 都支持 NSCoding 协议\nNSString *path = @"/Users/xiushan.fan/Desktop/arrfile";\nNSArray *subArray1 = @[[NSMutableString stringWithString:@"1"]];\nNSArray *subArray2 = @[[NSMutableString stringWithString:@"2"]];\nNSArray *wholeArr = @[subArray1,subArray2];\n[NSKeyedArchiver archiveRootObject:wholeArr toFile:path];\nNSLog(@"wholeArr = %@,wholeArr = %p,subArr1 = %p,elemement = %p",wholeArr,wholeArr,[wholeArr objectAtIndex:0],[[wholeArr objectAtIndex:0] objectAtIndex:0]);\nNSArray *unarchivedArray = [NSKeyedUnarchiver unarchiveObjectWithFile:path];\n//NSArray *unarchivedArray = [[NSArray alloc] initWithArray:wholeArr copyItems:YES];\nNSLog(@"unarchivedArray = %@, unarchivedArray = %p ,subArr1 = %p,elemement = %p",unarchivedArray,unarchivedArray,[unarchivedArray objectAtIndex:0],[[unarchivedArray objectAtIndex:0] objectAtIndex:0]);\n---\n> FRCopyDemo wholeArr = ( ( 1 ),( 2 ) ),wholeArr = 0x100422c60,subArr1 = 0x100406930,elemement = 0x100422580\n> FRCopyDemo unarchivedArray = (\n(1 ), ( 2 )), unarchivedArray = 0x1004273a0 ,subArr1 = 0x1004039c0,elemement = 0x100424230\n')])])]),o("p",[e._v("可以看到 "),o("code",[e._v("NSCoding")]),e._v(" 进行转化之后所有的元素的内存地址均不相同。")]),e._v(" "),o("h1",{attrs:{id:"copy-和属性"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copy-和属性"}},[e._v("#")]),e._v(" Copy 和属性")]),e._v(" "),o("p",[e._v("被 "),o("code",[e._v("copy attribute")]),e._v(" 修饰的属性，在被赋值的时候，新值其实是会收到一个 "),o("code",[e._v("copyWithZone:")]),e._v(" 的消息")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('@interface FRObj : NSObject<NSCopying>\n@end\n@implementation FRObj\n- (id)copyWithZone:(NSZone *)zone {\n    FRObj *obj = [[FRObj allocWithZone:zone] init];\n    NSLog(@"FRObj copy with zone self %@",self);\n    return obj;\n}\n@end\n@interface FRModel : NSObject<NSCopying>\n@property (nonatomic,copy) FRObj *name;\n@end\n\nFRModel *model = [[FRModel alloc] init];\nFRObj *obj = [[FRObj alloc] init];\nNSLog(@"obj %@",obj);\nmodel.name = obj;\n---\n> FRCopyDemo obj <FRObj: 0x1004001c0>\n> FRCopyDemo FRObj copy with zone self <FRObj: 0x1004001c0>\n')])])]),o("p",[e._v("可以看到 "),o("code",[e._v("FRObj")]),e._v(" 赋值的时候自己收到了一条 "),o("code",[e._v("copyWithZone:")]),e._v(" 的消息。\n具体的底层实现可以参考 "),o("a",{attrs:{href:"https://fanxiushan.github.io/2018/01/09/%E5%B1%9E%E6%80%A7-attribute-%E6%80%BB%E7%BB%93/",target:"_blank",rel:"noopener noreferrer"}},[e._v("属性 attribute 总结"),o("OutboundLink")],1),e._v(" 里的 "),o("code",[e._v("copy attribute")]),e._v(" 部分")]),e._v(" "),o("h1",{attrs:{id:"一些-qa"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#一些-qa"}},[e._v("#")]),e._v(" 一些 QA")]),e._v(" "),o("p",[o("strong",[e._v("Q: copy 关键字一般在哪些场景下使用？")]),e._v("\nA: 1."),o("code",[e._v("NSString/NSArray/NSDictionary")]),e._v(" 这些类使用，因为这些类都有对应的可变类型。 2. MRC 下修饰 "),o("code",[e._v("block")]),e._v(" 属性需要使用 "),o("code",[e._v("copy")]),e._v("。ARC 下可以使用 "),o("code",[e._v("copy/strong")]),e._v(" 去修饰 "),o("code",[e._v("block")]),e._v("，一般也使用 "),o("code",[e._v("copy")]),e._v(",给人感觉比较直观。")]),e._v(" "),o("blockquote",[o("p",[e._v("这个的对应的问题是，"),o("code",[e._v("NSString")]),e._v(" 使用什么修饰符修饰？为什么？答案是使用 "),o("code",[e._v("copy")]),e._v(" 修饰符，原因是 "),o("code",[e._v("NSString")]),e._v(" 用 "),o("code",[e._v("strong")]),e._v(" 修饰符的时候如果指向自己的可变类型，当可变类型内容修改的时候，"),o("code",[e._v("NSString")]),e._v(" 属性也会跟着一起修改，这不是我们希望看到的。同时根据刚才的分析，使用 "),o("code",[e._v("copy")]),e._v(" 修饰并不会给 "),o("code",[e._v("NSString")]),e._v(" 造成额外的负担，因为仅仅是浅拷贝而已。")])]),e._v(" "),o("p",[o("strong",[e._v("Q: 这个写法会出什么问题： @property (copy) NSMutableArray *array;")]),e._v("\nA: 当给 "),o("code",[e._v("array")]),e._v(" 赋值的时候可变对象会变为不可变对象，其实是向被赋值的对象发送了一个 "),o("code",[e._v("copy")]),e._v(" 消息， "),o("code",[e._v("copy")]),e._v(" 的默认实现就是将可变对象变为不可变对象。属性里也没有 "),o("code",[e._v("mutablecopy")]),e._v(" 这种修饰符，所以只能手动发送 "),o("code",[e._v("mutableCopy")]),e._v(" 消息达到目的。\n"),o("a",{attrs:{href:"https://stackoverflow.com/questions/46211849/property-of-mutable-type-nsmutabledictionary-has-copy-attribute-an-immutabl",target:"_blank",rel:"noopener noreferrer"}},[e._v("Property of mutable type 'NSMutableDictionary' has 'copy' attribute; an immutable object will be stored instead"),o("OutboundLink")],1)]),e._v(" "),o("p",[o("strong",[e._v("Q: 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？")]),e._v("\nA: 实现 "),o("code",[e._v("NSCopying")]),e._v(" 协议，实现 "),o("code",[e._v("copyWithZone:")]),e._v(" 方法. 直接发送 "),o("code",[e._v("copy")]),e._v(" 消息就好了")]),e._v(" "),o("h1",{attrs:{id:"参考地址"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#参考地址"}},[e._v("#")]),e._v(" 参考地址")]),e._v(" "),o("p",[o("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3",target:"_blank",rel:"noopener noreferrer"}},[e._v("Collections Programming Topics - Copying Collections"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCopying.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cocoa Core Competencies - Object copying"),o("OutboundLink")],1),e._v("\nEffective Objective-C 2.0 - 理解 NSCopying 协议\n"),o("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i",target:"_blank",rel:"noopener noreferrer"}},[e._v("Advanced Memory Management Programming Guide - About Memory Management"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://www.zybuluo.com/MicroCai/note/50592",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS 集合的深复制与浅复制"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://juejin.im/entry/581c6c2aa0bb9f0058a26f81",target:"_blank",rel:"noopener noreferrer"}},[e._v("Objective-C copy，看我就够了"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"http://zhangbuhuai.com/copy-in-objective-c/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Objective-C copy 那些事儿"),o("OutboundLink")],1)])])}),[],!1,null,null,null);o.default=r.exports}}]);