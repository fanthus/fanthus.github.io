(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{323:function(t,e,s){t.exports=s.p+"assets/img/wechat_qrcode.c0c8a471.png"},457:function(t,e,s){t.exports=s.p+"assets/img/objc_object&objc_class.d9696817.png"},458:function(t,e,s){t.exports=s.p+"assets/img/objc_class_isa.32978bf9.png"},459:function(t,e,s){t.exports=s.p+"assets/img/objc-inheritance.abc6f5d8.png"},680:function(t,e,s){"use strict";s.r(e);var a=s(5),_=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("其实也不好说是学习笔记还是复习笔记了，Objective-C 这语言从毕业开始一直用，直到 18 年前后换成了 Swift. 前几天看 JS 原型链的时候发现，这个和 OC 语言的继承体系好像啊，趁着这个机会回顾一下 OC 语言中的继承实现。")]),t._v(" "),e("p",[t._v("说起 OC 的继承实现就不能不提到支持 OC 这门语言运行的机制 "),e("code",[t._v("runtime")]),t._v(". 网上相关的文章已经介绍烂了，为了方便我自己之后回顾，我还是从自己理解的角度再聊一下 "),e("code",[t._v("runtime")]),t._v(" 的相关概念，同时也和别的语言进行一下对比。")]),t._v(" "),e("h1",{attrs:{id:"objective-c语言介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#objective-c语言介绍"}},[t._v("#")]),t._v(" Objective-C语言介绍")]),t._v(" "),e("p",[t._v("OC 语言是 C 语言的超集，在 C 语言的基础上提供面向对象的能力和动态运行时。和 "),e("code",[t._v("JavaScript")]),t._v(" 相比，OC 是一门编译型的语言，OC 编译完之后会生成一个 mach-o 文件，作为可执行文件。")]),t._v(" "),e("p",[t._v("我自己理解 OC 其实并不算是静态类型语言，虽然在写 OC 代码的时候会声明数据的类型，但是编译器并不会严格的检查数据类型。比如我们在 OC 里面这样写代码，编译器并不会报错，而只是给个警告 ⚠️")]),t._v(" "),e("div",{staticClass:"language-jsx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-jsx"}},[e("code",[t._v("NSString "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("str "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" @"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Warning : Incompatible pointer types initializing 'NSString *' with an expression of type 'NSNumber *'")]),t._v("\n")])])]),e("p",[t._v("本质上是因为对象本质都是运行时创建的（运行时系统提供了创建方法），所以仅仅凭编译没有办法确定数据的真正类型。从这点上来说 OC 也不算是强类型语言，相对于 Swfit 来说，OC 类型系统对类型的检查并不足够严格。至于 JavaScript 就更谈不上强类型语言了，我脑海里突然冒出一个想法，JavaScript 有类型检查系统吗…")]),t._v(" "),e("blockquote",[e("p",[t._v("弱/强类型指的是语言类型系统的类型检查的严格程度。比如强类型语言中不允许有任何的隐式类型转换，而弱类型语言则允许任意的数据隐式类型转换。\n静态/动态语言区分标准，应该就是类型检查的时机，编译时检查就是静态语言，运行时检查就是动态语言。")])]),t._v(" "),e("h1",{attrs:{id:"运行时系统-runtime-简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运行时系统-runtime-简介"}},[t._v("#")]),t._v(" 运行时系统(runtime)简介")]),t._v(" "),e("p",[t._v("作为动态类型的语言 Objective-C 语言尽可能地将许多决策从编译时间和链接时间推迟到运行时。只要有可能，它会以动态方式执行操作。这意味着该语言不仅需要编译器，还需要运行时系统来执行编译后的代码。运行时系统充当了Objective-C语言的一种操作系统；它是使语言正常工作的基础。")]),t._v(" "),e("p",[t._v("正是运行时机制的存在，让 OC 中的很多动态特性成为可能。")]),t._v(" "),e("blockquote",[e("p",[t._v("Objective-C运行时有两个版本 - "),e("code",[t._v("modern")]),t._v(" 和 "),e("code",[t._v("legacy")]),t._v("。两者最大的区别是：在 "),e("code",[t._v("modern")]),t._v(" 时中，如果您更改了类中实例变量的布局，则不必重新编译继承自它的类。原因是底层的 "),e("code",[t._v("objc_class")]),t._v("  修改了数据结构实现。")]),t._v(" "),e("p",[t._v("有意思的是，Objective-C 2.0 版本是 2012 年推出的，国内 2012 年移动互联网开始快速发展，很多人也差不多这时候开始入行，但是直到 17、18 年很多人分析 "),e("code",[t._v("runtime")]),t._v(" 还是用的 "),e("code",[t._v("legacy")]),t._v(" 版本的数据结构。")])]),t._v(" "),e("h2",{attrs:{id:"进入运行时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进入运行时"}},[t._v("#")]),t._v(" 进入运行时")]),t._v(" "),e("p",[t._v("从上层语言层面看来，Objective-C 中所有的类都需要继承自 "),e("a",{attrs:{href:"https://developer.apple.com/documentation/objectivec/nsobject",target:"_blank",rel:"noopener noreferrer"}},[t._v("NSObject"),e("OutboundLink")],1),t._v(" 类，即 "),e("code",[t._v("NSObject")]),t._v(" 是 OC 类继承体系中的根类，为什么所有的 OC 类都要继承 NSObject 呢？"),e("strong",[t._v("因为它提供了所有类的动态特性")]),t._v("。至于它是如何做到提供类的的动态特性的？介绍完继承体系相信你就能明白。")]),t._v(" "),e("p",[e("strong",[t._v("我们从 "),e("code",[t._v("NSObject")]),t._v(" 类这里进入了冰层之下的 OC runtime 体系")]),t._v("，看看运行时是如何支撑 OC 各种动态特性的，这篇文章里，我们主要还是想看看 OC 的继承体系是如何做到的。")]),t._v(" "),e("blockquote",[e("p",[t._v("苹果在自己的 "),e("a",{attrs:{href:"https://opensource.apple.com/releases/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Apple Source"),e("OutboundLink")],1),t._v(" 里提供了 "),e("code",[t._v("runtime")]),t._v(" 的源码，目前 macOS 13.5 带的 runtime 版本是 "),e("code",[t._v("objc4-876")]),t._v("。我在网上找了"),e("a",{attrs:{href:"https://github.com/LGCooci/KCObjc4_debug",target:"_blank",rel:"noopener noreferrer"}},[t._v("一份能编译 runtime 的版本"),e("OutboundLink")],1),t._v("，这样方便我们调试。")])]),t._v(" "),e("h2",{attrs:{id:"运行时数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据结构"}},[t._v("#")]),t._v(" 运行时数据结构")]),t._v(" "),e("p",[t._v("NSObject 的底层实现是什么样子？"),e("code",[t._v("NSObject.h")]),t._v(" 文件中的 "),e("code",[t._v("NSObject")]),t._v(" 定义如下：")]),t._v(" "),e("div",{staticClass:"language-objectivec extra-class"},[e("pre",{pre:!0,attrs:{class:"language-objectivec"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@interface")]),t._v(" NSObject "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("NSObject"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[e("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("pragma")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token expression"}},[t._v("clang diagnostic push")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[e("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("pragma")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token expression"}},[t._v("clang diagnostic ignored ")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-Wobjc-interface-ivars"')])]),t._v("\n    Class isa  OBJC_ISA_AVAILABILITY"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[e("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("pragma")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token expression"}},[t._v("clang diagnostic pop")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[e("code",[t._v("NSObject")]),t._v(" 的定义中只包含了成员变量 "),e("code",[t._v("isa")]),t._v("。这里面的 "),e("code",[t._v("Class")]),t._v(" 关键字是表示类，而在底层实现中 "),e("code",[t._v("Class")]),t._v(" 关键字就是 "),e("code",[t._v("stuct objc_class *")]),t._v("，并没有魔法。所以相当于 "),e("code",[t._v("NSObject")]),t._v(" 类只是在 "),e("code",[t._v("objc_class")]),t._v(" 外面包了一层而已。")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// An opaque type that represents an Objective-C class.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("objc_class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Class\n")])])]),e("p",[t._v("接着引出到运行时底层最基础的数据结构 "),e("code",[t._v("objc_class")]),t._v(" 以及 "),e("code",[t._v("objc_object")]),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"objc-class-objc-object"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#objc-class-objc-object"}},[t._v("#")]),t._v(" "),e("strong",[t._v("objc_class & objc_object")])]),t._v(" "),e("p",[t._v("翻看运行时源码会发现，"),e("code",[t._v("objc_class")]),t._v(" 和 "),e("code",[t._v("objc_object")]),t._v(" 其实都是 C 语言结构体，整个运行时的底层也都是 C/C++ 实现的。")]),t._v(" "),e("p",[t._v("关于这两个数据结构，网上有很多介绍的文章，可以搜索运行时关键字搜索。")]),t._v(" "),e("blockquote",[e("p",[t._v("源码中依然保留了 OC "),e("code",[t._v("legacy")]),t._v(" 版本的 "),e("code",[t._v("runtime")]),t._v(" 部分的数据结构定义，注意不要搞混。"),e("code",[t._v("legacy")]),t._v(" 运行时数据结构相关的定义在 "),e("code",[t._v("objc-runtime-old.h")]),t._v(" 文件里。")])]),t._v(" "),e("p",[e("code",[t._v("objc_object")]),t._v(" 表示的类实例，"),e("code",[t._v("objc_class")]),t._v(" 则表示类对象。列一下这两个类的成员变量")]),t._v(" "),e("p",[e("img",{attrs:{src:s(457),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("而 "),e("code",[t._v("objc_class")]),t._v(" 是继承 "),e("code",[t._v("objc_object")]),t._v(" 的。")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("objc_class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" objc_object "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("isa_t")]),t._v(" isa"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//在 objc_object 中")]),t._v("\n    Class superclass"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("cache_t")]),t._v(" cache"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("class_data_bits_t")]),t._v(" bits"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("这里涉及到 "),e("code",[t._v("isa_t")]),t._v(" 这个数据类型，这个数据类型内部比较复杂，这里不做具体介绍，简单说就是存储一个指针，指向了当前对象所属类，"),e("strong",[t._v("所以本质上除了类实例之外，类也是对象。")])]),t._v(" "),e("p",[t._v("那问题来了，如果 "),e("code",[t._v("objc_object")]),t._v(" 中的 "),e("code",[t._v("isa")]),t._v(" 是指向实例所属类的话，"),e("code",[t._v("objc_class")]),t._v(" 中的 "),e("code",[t._v("isa")]),t._v(" 是指向哪里呢？"),e("strong",[t._v("元类。")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(458),alt:"Untitled"}})]),t._v(" "),e("h3",{attrs:{id:"元类-meta-class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元类-meta-class"}},[t._v("#")]),t._v(" "),e("strong",[t._v("元类(meta-class)")])]),t._v(" "),e("p",[t._v("什么是元类呢？其实就是类对象的类。")]),t._v(" "),e("p",[t._v("但为什么语言机制要涉及元类呢？")]),t._v(" "),e("p",[t._v("回顾上面的对象的表示 "),e("code",[t._v("objc_object")]),t._v("，它里面只有指向所属类的 "),e("code",[t._v("isa")]),t._v(" 指针，并没有额外的成员变量保存对象别的信息，比如对象可调用的方法列表和对象包含的属性列表等。想要获取这些信息，必须通过对象的 "),e("code",[t._v("isa")]),t._v(" 指针找到所属类，在类中查找方法列表和成员变量。")]),t._v(" "),e("blockquote",[e("p",[e("code",[t._v("objc_class")]),t._v(" 类中的 "),e("code",[t._v("class_data_bits_t")]),t._v(" 结构体实例保存着指向方法、属性和协议列表的内存地址。")])]),t._v(" "),e("p",[t._v("同理，类方法调用时，通过类的 "),e("code",[t._v("isa")]),t._v(" 在元类中获取类方法的实现。")]),t._v(" "),e("p",[t._v("所以元类是必要的，它保存了类的方法和属性列表等信息。")]),t._v(" "),e("p",[t._v("根据我们之前说的类也是对象，那元类的 "),e("code",[t._v("isa")]),t._v(" 指针指向哪里呢？答案是指向 "),e("code",[t._v("NSObject")]),t._v(" 类的元类。而 "),e("code",[t._v("NSObject")]),t._v(" 元类的 "),e("code",[t._v("isa")]),t._v(" 指针则指向其自身。")]),t._v(" "),e("h3",{attrs:{id:"父类-superclass"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父类-superclass"}},[t._v("#")]),t._v(" "),e("strong",[t._v("父类(superclass)")])]),t._v(" "),e("p",[e("code",[t._v("objc_class")]),t._v(" 中有 "),e("code",[t._v("superclass")]),t._v(" 成员变量，"),e("code",[t._v("superclass")]),t._v(" 就是指向当前类的父类。这个概念很理解就不赘述了。")]),t._v(" "),e("h2",{attrs:{id:"基于运行时的继承体系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于运行时的继承体系"}},[t._v("#")]),t._v(" 基于运行时的继承体系")]),t._v(" "),e("p",[t._v("基于我们上面对元类和父类的分析，Objective-C 的整体继承体系如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(459),alt:"Untitled"}})]),t._v(" "),e("p",[t._v("看起来是比 "),e("a",{attrs:{href:"https://fanthus.github.io/2023/08/31/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%B1%BB-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS 的原型链"),e("OutboundLink")],1),t._v("还要复杂的存在，JS 似乎没有元类这个概念，Objective-C 使用两个指针("),e("code",[t._v("isa")]),t._v(" & "),e("code",[t._v("superclass")]),t._v(")完成了类、元类和父类查找，而 JS 只用一个 "),e("code",[t._v("__proto__")]),t._v(" 属性来做这件事。")]),t._v(" "),e("h2",{attrs:{id:"基于运行时的消息查找体系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于运行时的消息查找体系"}},[t._v("#")]),t._v(" 基于运行时的消息查找体系")]),t._v(" "),e("p",[t._v("Objective-C 的方法查找机制也是以这个体系为框架进行查找，当我们调用实例方法的话，运行时会先通过isa指针找到实例所属类，在类的方法列表找有没有这个方法。如果在方法列表中找不到该选择器，"),e("code",[t._v("objc_msgSend")]),t._v(" 会继续跟踪指向父类(superclass)的指针，并尝试在其方法列表中查找该选择器。连续的失败会导致 "),e("code",[t._v("objc_msgSend")]),t._v(" 沿着类层次结构向上查找，直到达到 "),e("code",[t._v("NSObject")]),t._v(" 类为止。如果 "),e("code",[t._v("NSObject")]),t._v(" 类依然没有此方法，则会走消息转发机制。")]),t._v(" "),e("h1",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[e("code",[t._v("Objective-C")]),t._v(" 语言是架在在运行时之上的，运行时是我们日常编写的各种代码的粘合剂，没有运行时机制，就谈不上 "),e("code",[t._v("Objective-C")]),t._v(" 的继承体系。整个 "),e("code",[t._v("Objective-C")]),t._v(" 的继承体系全部都建立在运行时之上。")]),t._v(" "),e("p",[t._v("回到之前的一个小问题，NSObject 是如何提供动态特性的？要知道自己写的类是只负责业务相关的逻辑，并不关心动态特性，但这些类都有动态特性，比如可以调用 为 -isKindOfClass: 之类的方法，本质上就是因为我们写的类都继承了 NSObject，当想自己的类实例发送消息的时候，这些消息发到 NSObject 去进行处理，即 NSObject 本身有动态特性的方法，子类继承了父类的能力，所有子类也有动态特性的方法。")]),t._v(" "),e("p",[t._v("参考地址:")]),t._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048",target:"_blank",rel:"noopener noreferrer"}},[t._v("Objective-C Runtime Programming Guide"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210",target:"_blank",rel:"noopener noreferrer"}},[t._v("Programming with Objective-C"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("What is a meta-class in Objective-C?"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("从 NSObject 的初始化了解 isa"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/_posts/2023-08-31-JS学习笔记-原型链_类_构造函数.html"}},[t._v("JS学习笔记-原型链&类&构造函数")])],1)]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("关注我的微信公众号，我在上面会分享我的日常所思所想。")]),t._v(" "),e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:s(323),width:"40%/"}})]),t._v(" "),e("Vssue",{attrs:{title:"Objective-C运行时学习笔记-继承体系"}})],1)}),[],!1,null,null,null);e.default=_.exports}}]);