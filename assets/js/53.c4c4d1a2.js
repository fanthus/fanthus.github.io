(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{351:function(t,e,r){t.exports=r.p+"assets/img/Jietu20180106-185957.a4a60542.png"},588:function(t,e,r){"use strict";r.r(e);var o=r(5),a=Object(o.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("ol",[e("li",[e("code",[t._v("@property")]),t._v(" 的本质是什么?")]),t._v(" "),e("li",[e("code",[t._v("@property")]),t._v(" 和运行时有什么关系?")]),t._v(" "),e("li",[e("code",[t._v("@property")]),t._v(" 一个 demo")])]),t._v(" "),e("h1",{attrs:{id:"property-的本质是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#property-的本质是什么"}},[t._v("#")]),t._v(" "),e("code",[t._v("property")]),t._v(" 的本质是什么")]),t._v(" "),e("p",[e("code",[t._v("@property")]),t._v(" 的本质就是成员变量加 "),e("code",[t._v("getter")]),t._v(" 和 "),e("code",[t._v("setter")]),t._v(" 方法。"),e("code",[t._v("getter")]),t._v(" 和 "),e("code",[t._v("setter")]),t._v(" 方法是编译器自动为我们生成的。我们也可以尝试去复写 "),e("code",[t._v("getter")]),t._v(" 和 "),e("code",[t._v("setter")]),t._v(" 方法，在设置成员变量前后增加一些我们想要的业务逻辑。")]),t._v(" "),e("p",[e("code",[t._v("@property")]),t._v(" 有不同的 "),e("code",[t._v("attribute")]),t._v(" : "),e("code",[t._v("readonly")]),t._v(","),e("code",[t._v("atomic")]),t._v(","),e("code",[t._v("nonatomic")]),t._v(" 等等。编译器会根据不同的 "),e("code",[t._v("attribute")]),t._v(" 生成不同的 "),e("code",[t._v("getter")]),t._v(" 和 "),e("code",[t._v("setter")]),t._v(" 方法")]),t._v(" "),e("h1",{attrs:{id:"property-和运行时有什么关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#property-和运行时有什么关系"}},[t._v("#")]),t._v(" "),e("code",[t._v("property")]),t._v(" 和运行时有什么关系?")]),t._v(" "),e("p",[t._v("来看下运行时系统对 "),e("code",[t._v("property")]),t._v(" 相关类型的定义")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("template <typename Element, typename List, uint32_t FlagMask>\nstruct property_list_t : entsize_list_tt<property_t, property_list_t, 0> {\n};\n\ntypedef struct property_t *objc_property_t;\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n\n/// Defines a property attribute\ntypedef struct {\n    const char *name;           /**< The name of the attribute */\n    const char *value;          /**< The value of the attribute (usually empty) */\n} objc_property_attribute_t;\n\n")])])]),e("blockquote",[e("p",[e("code",[t._v("entsize_list_tt")]),t._v(" 是通过 "),e("code",[t._v("C++")]),t._v(" 的容器类，提供了容器类的基本方法，通过这些基本方法可以管理数据并以遍历的方式获取容器内的数据。"),e("code",[t._v("property_list_t")]),t._v(" 是管理 "),e("code",[t._v("property_t")]),t._v(" 的一个属性类型。")])]),t._v(" "),e("p",[t._v("了解了基本数据类型之后，我们来讨论几个问题")]),t._v(" "),e("h2",{attrs:{id:"类是怎么获取到-property-的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类是怎么获取到-property-的"}},[t._v("#")]),t._v(" 类是怎么获取到 "),e("code",[t._v("@property")]),t._v(" 的?")]),t._v(" "),e("p",[t._v("看源码及注释")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("objc_property_t class_getProperty(Class cls, const char *name)\n{\n    .......\n    //依次遍历父类\n    for ( ; cls; cls = cls->superclass) {\n        //遍历当前类的属性列表\n        for (auto& prop : cls->data()->properties) {\n            //比较字符串如果相等就返回当前的 property\n            if (0 == strcmp(name, prop.name)) {\n                return (objc_property_t)&prop;\n            }\n        }\n    }\n\n    return nil;\n}\n")])])]),e("h2",{attrs:{id:"类是怎么增加-property-的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类是怎么增加-property-的"}},[t._v("#")]),t._v(" 类是怎么增加 "),e("code",[t._v("property")]),t._v(" 的?")]),t._v(" "),e("p",[t._v("看源码及注释")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("static bool _class_addProperty(Class cls, const char *name,\n                   const objc_property_attribute_t *attrs, unsigned int count,\n                   bool replace)\n{\n    if (!cls) return NO;\n    if (!name) return NO;\n    //先从当前类获取指定名称的 property，如果有而且 caller 不想替换则直接返回\n    property_t *prop = class_getProperty(cls, name);\n    if (prop  &&  !replace) {\n        // already exists, refuse to replace\n        return NO;\n    }\n    //替换当前 property 流程，其实就是把 property 相关的 attributes 进行替换。\n    else if (prop) {\n        // replace existing\n        rwlock_writer_t lock(runtimeLock);\n        try_free(prop->attributes);\n        //参数 count 是 attrs 的数量。\n        prop->attributes = copyPropertyAttributeString(attrs, count);\n        return YES;\n    }\n    else {\n        //为新的 property 分配空空间。值得注意的是这里并不是直接分配的 property 而是通过 property_list 进行操作的。\n        property_list_t *proplist = (property_list_t *)malloc(sizeof(*proplist));\n        proplist->count = 1;\n        proplist->entsizeAndFlags = sizeof(proplist->first);\n        proplist->first.name = strdupIfMutable(name);\n        proplist->first.attributes = copyPropertyAttributeString(attrs, count);\n        //cls->data() 拿到 class_rw_t 结构体，结构体里的 properties 是 property_array_t 类型，将新的 property 加入到 property 数组中。\n        cls->data()->properties.attachLists(&proplist, 1);\n\n        return YES;\n    }\n}\n")])])]),e("h2",{attrs:{id:"property-和成员变量是怎么对应起来的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#property-和成员变量是怎么对应起来的"}},[t._v("#")]),t._v(" "),e("code",[t._v("property")]),t._v(" 和成员变量是怎么对应起来的？")]),t._v(" "),e("p",[t._v("其实是在编译这一步就做好了。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("@interface Fan : NSObject\n@property (nonatomic,strong) NSString *name;\n@end\n.....\n")])])]),e("p",[t._v("编译 clang -rewrite-objc main.m 之后结果")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('typedef struct objc_object Fan;\n\nextern "C" unsigned long OBJC_IVAR_$_Fan$_name;\nstruct Fan_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n\tNSString *_name;\n};\n// @property (atomic,strong) NSString *name;\n/* @end */\n...\n')])])]),e("p",[t._v("可以看到 "),e("code",[t._v("name")]),t._v(" 属性变成了成员变量 "),e("code",[t._v("_name")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"property-一个-demo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#property-一个-demo"}},[t._v("#")]),t._v(" "),e("code",[t._v("property")]),t._v(" 一个 demo")]),t._v(" "),e("p",[t._v("我们之前猜测不同 "),e("code",[t._v("property")]),t._v(" 的 "),e("code",[t._v("attribute")]),t._v(" 会对编译器造成影响，即生成出来的 "),e("code",[t._v("setter")]),t._v(" 和 "),e("code",[t._v("getter")]),t._v(" 方法可能不同，比如 "),e("code",[t._v("atomic")]),t._v(" 的 "),e("code",[t._v("setter")]),t._v(" 方法可能会有锁的实现，于是我补充了上面源码的 "),e("code",[t._v("getter")]),t._v(" 和 "),e("code",[t._v("setter")]),t._v(" 实现：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("static NSString * _I_Fan_name(Fan * self, SEL _cmd) { return (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)); }\nstatic void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) { (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)) = name; }\n")])])]),e("p",[t._v("发现 setter 并没有什么特别的地方...")]),t._v(" "),e("p",[t._v("难道我的验证有问题吗？感觉不应该。我尝试在 demo 中给 "),e("code",[t._v("name")]),t._v(" 属性赋值，并打了个符号断点 "),e("code",[t._v("objc_setProperty_atomic")]),t._v(" 发现这个方法确实走了，所以 "),e("code",[t._v("clang")]),t._v(" 出来的结果应该是有问题的。怎么生成更准确的编译结果我也不清楚。。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(351),alt:"Jietu20180106-185957"}})]),t._v(" "),e("p",[t._v("你也许会问 "),e("code",[t._v("objc_setProperty_atomic")]),t._v(" 这个是干什么用的，翻源码到 "),e("code",[t._v("objc-accessors.mm")]),t._v(" 这个文件看，可以看到不同的修饰符走了不同的设置属性的方法比如 "),e("code",[t._v("objc_setProperty_nonatomic")]),t._v("，"),e("code",[t._v("objc_setProperty_atomic")]),t._v("，"),e("code",[t._v("objc_setProperty_atomic_copy")]),t._v(" 最终他们都调用了 "),e("code",[t._v("reallySetProperty")]),t._v(" 这个方法接收了众多参数，根据不同的参数，走了不同的执行流。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n    id oldValue;\n    //这里的 offset 其实就是上一步编译时候确定的。\n    id *slot = (id*) ((char*)self + offset);\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        //在这里看到 atomic 确实是使用自旋锁来对赋值进行了保护。\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;\n        slotlock.unlock();\n    }\n    objc_release(oldValue);\n}\n")])])]),e("p",[t._v("可以看到，属性机制的实现不仅靠编译时，运行时也起了很大的作用。")]),t._v(" "),e("p",[t._v("一个思考，能否在运行时候动态添加属性呢？")])])}),[],!1,null,null,null);e.default=a.exports}}]);