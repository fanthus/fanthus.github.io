(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{353:function(e,o,a){e.exports=a.p+"assets/img/Jietu20180125-103109.09b0529d.png"},354:function(e,o,a){e.exports=a.p+"assets/img/15168026389568.ee9d91f9.jpg"},355:function(e,o,a){e.exports=a.p+"assets/img/15170502117985.4eb2f47c.jpg"},593:function(e,o,a){"use strict";a.r(o);var t=a(5),l=Object(t.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("从一些问题开始")]),e._v(" "),o("ol",[o("li",[e._v("什么是 "),o("code",[e._v("AutoreleasePool")]),e._v(" ? 说明一下 "),o("code",[e._v("NSAutoreleasePool")]),e._v(" 具体机制?")]),e._v(" "),o("li",[e._v("ARC 时代和 MRC 时代的 "),o("code",[e._v("AutoreleasePool")]),e._v(" 机制有什么区别？")]),e._v(" "),o("li",[o("code",[e._v("AutoreleasePool")]),e._v(" 的实现机制?")]),e._v(" "),o("li",[o("code",[e._v("AutoreleasePool")]),e._v(" 和 NSRunloop 有什么关系？")]),e._v(" "),o("li",[o("code",[e._v("AutoreleasePool")]),e._v(" 和线程有什么关系?")]),e._v(" "),o("li",[e._v("什么时候需要我们手动创建 "),o("code",[e._v("AutoreleasePool")]),e._v(" ?")])]),e._v(" "),o("h2",{attrs:{id:"什么是-autoreleasepool-如何理解-nsautoreleasepool"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么是-autoreleasepool-如何理解-nsautoreleasepool"}},[e._v("#")]),e._v(" 什么是 AutoreleasePool ? 如何理解 NSAutoreleasePool?")]),e._v(" "),o("p",[o("code",[e._v("NSAutoreleasePool")]),e._v(" 对象的官方说明是一个支持 "),o("code",[e._v("Cocoa")]),e._v(" 引用计数式内存管理的一个对象。 当池子排掉的时候向池子内存储的对象发送 "),o("code",[e._v("release")]),e._v(" 消息。")]),e._v(" "),o("blockquote",[o("p",[e._v("An object that supports Cocoa’s reference-counted memory management system.\nAn autorelease pool stores objects that are sent a release message when the pool itself is drained.")])]),e._v(" "),o("p",[e._v("具体机制说明：\n在引用计数式的内存管理中，"),o("code",[e._v("NSAutoreleasePool")]),e._v(" 对象包含了收到了 "),o("code",[e._v("_autorelease")]),e._v(" 消息的对象，这些 "),o("code",[e._v("autorelease")]),e._v(" 对象（我们称被标记了 "),o("code",[e._v("__autorelease")]),e._v(" 的对象为 "),o("code",[e._v("autorelease")]),e._v(" 对象）的生命周期被延长到了这个 "),o("code",[e._v("NSAutoreleasePool")]),e._v(" drain 的时候。也可以这么说 "),o("code",[e._v("autorelease")]),e._v(" 和 "),o("code",[e._v("release")]),e._v(" 的区别仅仅是 "),o("code",[e._v("autorelease")]),e._v(" 是延时释放(即等待 "),o("code",[e._v("AutoreleasePool drain")]),e._v(") 而 "),o("code",[e._v("release")]),e._v(" 是立即释放。")]),e._v(" "),o("p",[e._v("感觉说到这儿，其实我们可以说 "),o("code",[e._v("NSAutoreleasePool")]),e._v(" 就是一个帮助我们管理内存的一个工具。")]),e._v(" "),o("p",[e._v("其实不光是我们自己可以手动创建 "),o("code",[e._v("NSAutoreleasePool")]),e._v(" 对象，系统也帮我们维护了一个 "),o("code",[e._v("NSAutoreleasePool")]),e._v(" 对象，在 "),o("code",[e._v("runloop")]),e._v(" 迭代中不断 "),o("code",[e._v("Push")]),e._v(" 和 "),o("code",[e._v("Pop")]),e._v("，从而不会堆积过多的 "),o("code",[e._v("autorelease")]),e._v(" 对象引起内存疯长。你可能会好奇，哪会有那么多 "),o("code",[e._v("autorelease")]),e._v(" 对象？举个例子来看一下：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('- (void)viewDidLoad {\n    [super viewDidLoad];\n    // str 其实是一个 autorelease 对象\n    NSString *str = [NSString stringWithFormat:@"sunnyxx"];\n    reference = str;\n}\n')])])]),o("p",[e._v("题外话：为啥 str 是一个 "),o("code",[e._v("autorelease")]),e._v(" 对象呢？\n这个就需要知道下内存管理的知识了，使用 "),o("code",[e._v("alloc")]),e._v(","),o("code",[e._v("new")]),e._v(","),o("code",[e._v("copy")]),e._v("和"),o("code",[e._v("mutableCopy")]),e._v("这些关键字生成的对象是自己持有，反之不是（参考 "),o("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-SW1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Memory Management Policy"),o("OutboundLink")],1),e._v("）。使用 "),o("code",[e._v("stringWithFormat:")]),e._v(" 类方法生成的 "),o("code",[e._v("str")]),e._v(" 没有持有它的对象，只能通过 "),o("code",[e._v("autorelease")]),e._v(" 这种方式来延长它的生命周期。具体 "),o("code",[e._v("autorelease")]),e._v(" 的时机是在 "),o("code",[e._v("stringWithFormat")]),e._v(" 内部做的。")]),e._v(" "),o("p",[o("code",[e._v("Cocoa")]),e._v(" 的 "),o("code",[e._v("Framework")]),e._v(" 里大量生成了 "),o("code",[e._v("autorelease")]),e._v(" 的对象，所以官方说明里 "),o("code",[e._v("Cocoa")]),e._v(" 代码执行是预期在一个 "),o("code",[e._v("autorelease")]),e._v(" 环境中。")]),e._v(" "),o("h2",{attrs:{id:"arc-时代和-mrc-时代的-autoreleasepool-机制有什么区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#arc-时代和-mrc-时代的-autoreleasepool-机制有什么区别"}},[e._v("#")]),e._v(" ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？")]),e._v(" "),o("p",[e._v("没啥根本区别，只是写法稍有不同。看两个 ARC 和 MRC 时代 "),o("code",[e._v("autorelease")]),e._v(" 的两个经典写法。")]),e._v(" "),o("p",[e._v("MRC 的 case:")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("NSAutoreleasePool *pool = [[NSAutorelease alloc] init];\nid obj = [[NSObject alloc] init];\n[obj autorelease];\n[pool drain];\n")])])]),o("p",[e._v("ARC 的 case(注:"),o("a",{attrs:{href:"https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/occ/cl/NSAutoreleasePool",target:"_blank",rel:"noopener noreferrer"}},[e._v("其实 MRC 也可以这么写"),o("OutboundLink")],1),e._v("):")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("@autoreleasepool {\n    //_autorelease 为所有权修饰符。\n    id _autorelease obj = [[NSObject alloc] init];\n}\n")])])]),o("p",[o("code",[e._v("ARC")]),e._v(" 中的几点变化：")]),e._v(" "),o("ol",[o("li",[o("p",[o("code",[e._v("ARC")]),e._v(" 中是不能使用 "),o("code",[e._v("autorelease")]),e._v(" 方法，也不能使用 "),o("code",[e._v("NSAutoreleasePool")]),e._v(" 类。")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("ARC")]),e._v(" 系统提供了 "),o("code",[e._v("@autoreleasepool")]),e._v(" 块来替代 "),o("code",[e._v("NSAutoreleasePool")]),e._v(" 对象的生成持有以及废弃的功能。")])]),e._v(" "),o("li",[o("p",[e._v("通过将对象赋值给附加了 "),o("code",[e._v("__autoreleaseing")]),e._v(" 修饰符变量来替代调用 "),o("code",[e._v("autorelease")]),e._v(" 方法。即")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("id obj = [[NSObject alloc] init];\n[obj autorelease];\n")])])]),o("p",[e._v("等价于")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("id _autorelease obj = [[NSObject alloc] init];\n")])])])])]),e._v(" "),o("p",[e._v("一般我们不会显式的去使用 "),o("code",[e._v("__autorelease")]),e._v(" 修饰符，因为 ARC 下编译器帮我们做了一些工作，即编译器会检查方法是否以 "),o("code",[e._v("alloc/new/copy/mutableCopy")]),e._v(" 开始，如果不是的话将返回的值对象注册到 "),o("code",[e._v("autoreleasePool")]),e._v("。")]),e._v(" "),o("p",[e._v("不需要显式地写 "),o("code",[e._v("__autorelease")]),e._v(" 的几种场景")]),e._v(" "),o("ol",[o("li",[o("p",[e._v("自动释放池随意生成对象，不需要显式地添加 "),o("code",[e._v("autorelease")]),e._v("。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("@autoreleasepool {\n    //默认的 strong 修饰符会自动处理这种情况.\n    id obj = [[NSObject alloc] init];\n}\n")])])])]),e._v(" "),o("li",[o("p",[e._v("函数返回值的场景")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("+ (NSArray *)array {\n    id obj = [[NSMutableArray alloc] init];\n    return obj;\n}\n")])])]),o("p",[e._v("在 MRC 时代，obj 是需要被发送 "),o("code",[e._v("autorelease")]),e._v(" 方法的，ARC 时代不需要这么做，这个对象作为函数的返回值会自动被注册到 "),o("code",[e._v("autoreleasePool")]),e._v(" 中")])]),e._v(" "),o("li",[o("p",[e._v("访问 "),o("code",[e._v("weak")]),e._v(" 变量的时肯定会涉及到 "),o("code",[e._v("autoreleasePool")])]),e._v(" "),o("p",[e._v("因为 "),o("code",[e._v("weak")]),e._v(" 对对象是弱引用，对象随时会被释放，但是使用 "),o("code",[e._v("autoreleasePool")]),e._v(" 会延时释放，保证 "),o("code",[e._v("weak")]),e._v(" 访问过程中不会出现对象被释放这种状况。")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("NSObject **obj")]),e._v(" 其实就是 "),o("code",[e._v("NSObject *_autorelease * obj")]),e._v("。\n因为"),o("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-SW1",target:"_blank",rel:"noopener noreferrer"}},[e._v("我们不持有通过引用返回的对象"),o("OutboundLink")],1),e._v("。这种情况只能是 "),o("code",[e._v("autorelease")]),e._v("。")])])]),e._v(" "),o("h2",{attrs:{id:"autoreleasepool-的实现机制"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool-的实现机制"}},[e._v("#")]),e._v(" AutoreleasePool 的实现机制?")]),e._v(" "),o("h3",{attrs:{id:"分析过程"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#分析过程"}},[e._v("#")]),e._v(" 分析过程")]),e._v(" "),o("p",[e._v("对以下代码所在文件执行 "),o("code",[e._v("clang -rewrite-objc xx.m")]),e._v(" 重写命令，可以看到 OC 对应的 C++ 的源码。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('int main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSLog(@"Hello, World!");\n    }\n    return 0;\n}\n')])])]),o("p",[e._v("转换后的 C++ 代码。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("int main(int argc, const char * argv[]) {\n    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0);\n    }\n    return 0;\n}\n")])])]),o("p",[e._v("可以看到 "),o("code",[e._v("@autoreleasepool")]),e._v(" 被转换为一个名为 "),o("code",[e._v("__AtAutoreleasePool")]),e._v(" 的数据结构。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("struct __AtAutoreleasePool {\n  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();}\n  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);}\n  void * atautoreleasepoolobj;\n};\n")])])]),o("p",[e._v("main 函数其实可以理解为")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("int main(int argc, const char * argv[]) {\n    {\n        void *atautoreleasepoolobj = objc_autoreleasePoolPush();\n        NSLog((NSString *)&__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0);\n        objc_autoreleasePoolPop(atautoreleasepoolobj);\n    }\n    return 0;\n}\n")])])]),o("p",[e._v("具体 "),o("code",[e._v("objc_autoreleasePoolPush")]),e._v(" 和 "),o("code",[e._v("objc_autoreleasePoolPop")]),e._v(" 的实现在 runtime 源码 "),o("code",[e._v("NSObject.mm")]),e._v("中可以找到。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("void * objc_autoreleasePoolPush(void) {\n    return AutoreleasePoolPage::push();\n}\n\nvoid objc_autoreleasePoolPop(void *ctxt) {\n    AutoreleasePoolPage::pop(ctxt);\n}\n")])])]),o("h3",{attrs:{id:"autoreleasepoolpage-的介绍"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepoolpage-的介绍"}},[e._v("#")]),e._v(" "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的介绍")]),e._v(" "),o("p",[e._v("这里涉及到了 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 这个数据结构，接下来就看下 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 这个数据结构是啥样的？"),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 是个 C++ 的类")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("class AutoreleasePoolPage  {\n    magic_t const magic;    //magic 用于对当前 AutoreleasePoolPage 完整性的校验\n    id *next;               //当前 autoreleasePoolPage 最上层的对象的指针。\n    pthread_t const thread; //thread 保存了当前页所在的线程\n    AutoreleasePoolPage * const parent;//指向上一个 AutoreleasePoolPage 对象.\n    AutoreleasePoolPage *child; //指向下一个 AutoreleasePoolPage 对象.\n    uint32_t const depth;\n    uint32_t hiwat;\n}\n")])])]),o("p",[o("strong",[e._v("关于 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的说明")])]),e._v(" "),o("ol",[o("li",[o("p",[e._v("可以看到其实并没有一个整体的自动释放池对象，自动释放池是由一个双向链表构成。当一个 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的空间被占满之后继续创建新的 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 对象。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("//child 指向的是下一个 AutoreleasePoolPage 对象的指针\n// 这个方法是当前 page 如果满的情况下创建新的 page.\nid *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) {\n    do {\n        if (page->child) page = page->child;\n        else page = new AutoreleasePoolPage(page);\n    } while (page->full());\n    ....\n    return page->add(obj);\n}\n// 初始化 pool 的方法 在这个里面对 parent 和 child 进行了赋值.\nAutoreleasePoolPage(AutoreleasePoolPage *newParent)\n    : magic(), next(begin()), thread(pthread_self()),\n      parent(newParent), child(nil),\n      depth(parent ? 1+parent->depth : 0),\n      hiwat(parent ? parent->hiwat : 0) {\n    if (parent) {\n        parent->child = this;\n    }\n}\n")])])])]),e._v(" "),o("li",[o("p",[e._v("每个 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 对象都存储着当前的线程 "),o("code",[e._v("id")]),e._v(" 参考上面的 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的初始化方法。使用 "),o("code",[e._v("pthread_self()")]),e._v(" 拿到当前的线程 "),o("code",[e._v("id")]),e._v(" 然后保存到 "),o("code",[e._v("thread")]),e._v(" 成员变量里。")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的内存大小是 4096 个字节。是 80386 机器上的每页的字节数。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("//初始化 AutoreleasePoolPage 的方法,size 是个宏定义的 4096\nstatic void * operator new(size_t size) {\n    return malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);\n}\n")])])])]),e._v(" "),o("li",[o("p",[o("code",[e._v("AutoreleasePoolPage")]),e._v(" 存储 "),o("code",[e._v("autorelease")]),e._v(" 对象是通过自己内部的 "),o("code",[e._v("next")]),e._v(" 指针去实现。从实现上可以看到 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 还是从低内存地址向高内存地址增长。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("id *add(id obj) {\n    id *ret = next;  // faster than `return next-1` because of aliasing\n    *next++ = obj;\n    return ret;\n}\n")])])]),o("p",[e._v("由此大致能得到 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的内存结构如图（来自 Sunny 大神博客）\n"),o("img",{attrs:{src:a(353),alt:"Jietu20180125-103109"}})])])]),e._v(" "),o("h3",{attrs:{id:"autorelease-消息调用栈"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#autorelease-消息调用栈"}},[e._v("#")]),e._v(" autorelease 消息调用栈")]),e._v(" "),o("p",[e._v("了解了这个数据结构后看下 "),o("code",[e._v("autorelease")]),e._v(" 消息的调用栈。")]),e._v(" "),o("p",[o("img",{attrs:{src:a(354),alt:""}}),e._v("\n我们看下 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 中 "),o("code",[e._v("autorelease")]),e._v(" 方法实现其实就是将 "),o("code",[e._v("autorelease")]),e._v(" 对象存储到 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的过程。下面是大致实现的代码")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("static inline id autorelease(id obj) {\n    ...\n    id *dest __unused = autoreleaseFast(obj);\n    ...\n    return obj;\n}\n//这个是将 obj 存入 AutoreleasePoolPage 的方法。\nstatic inline id *autoreleaseFast(id obj) {\n    //hotPage 应该是去 TLS(线程本地存储) 中获取 AutoreleasePoolPage。\n    //如果是程序刚启动的话，这儿肯定拿到的空。\n    AutoreleasePoolPage *page = hotPage();\n    if (page && !page->full()) {\n        // AutoreleasePoolPage 不满的时候直接往进加\n        return page->add(obj); //绝大多数情况我们走的都是这个分支。\n    } else if (page) {\n        // AutoreleasePoolPage 满了，则创建新的 page，将 obj 放到新的 page 里去.\n        return autoreleaseFullPage(obj, page);\n    } else {\n        // 创建新的 page.\n        return autoreleaseNoPage(obj);\n    }\n}\n")])])]),o("h3",{attrs:{id:"autorelease-pop-消息"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#autorelease-pop-消息"}},[e._v("#")]),e._v(" autorelease pop 消息")]),e._v(" "),o("p",[e._v("对应 "),o("code",[e._v("push")]),e._v(" 的是 "),o("code",[e._v("pop")]),e._v("，"),o("code",[e._v("pop")]),e._v(" 即为将存储到 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的对象释放对应原型为")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("void objc_autoreleasePoolPop(void *ctxt) {\n    AutoreleasePoolPage::pop(ctxt);\n}\n")])])]),o("p",[e._v("注意的是这里并没有直接传入对象，而是传入了一个 "),o("code",[e._v("ctxt")]),e._v(" 的指针，根据内部实现来看，自动释放池根据 "),o("code",[e._v("ctxt")]),e._v(" 拿到它当前所在的 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" ，然后将 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 的 "),o("code",[e._v("ctxt")]),e._v(" 的位置开始到到最新的 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 存储的 "),o("code",[e._v("autorelease")]),e._v(" 对象全部释放。即我们可以理解为自动释放池代码块儿开始的时候会在 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 进行一个占位，然后将后续的 "),o("code",[e._v("autorelease")]),e._v(" 对象都放到占位后，这样就能确定当前自动释放池块儿里的对象是从哪到哪，理解了这一点也就能理解 "),o("code",[e._v("autorelease")]),e._v(" 的嵌套实现了。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("static inline void pop(void *token)  {\n    AutoreleasePoolPage *page; id *stop;\n    ..\n    page = pageForPointer(token); //拿到 token 所在的 AutoreleasePoolPage\n    stop = (id *)token;\n    if (*stop != POOL_BOUNDARY) {\n        if (stop == page->begin()  &&  !page->parent) {\n            // Start of coldest page may correctly not be POOL_BOUNDARY:\n            // 1. top-level pool is popped, leaving the cold page in place\n            // 2. an object is autoreleased with no pool\n        } else {\n            return badPop(token);\n        }\n    }\n    if (PrintPoolHiwat) printHiwat();\n    page->releaseUntil(stop);  //一直释放对象到 token 的位置.\n}\n//一直释放对象的函数\nvoid releaseUntil(id *stop)  {\n    while (this->next != stop) {\n        AutoreleasePoolPage *page = hotPage(); //拿到当前的 page.\n        id obj = *--page->next;\n        memset((void*)page->next, SCRIBBLE, sizeof(*page->next));\n        if (obj != POOL_BOUNDARY) {\n            objc_release(obj);  //取出对象不断发送 relesse 消息..\n        }\n    }\n    setHotPage(this);\n}\n")])])]),o("h2",{attrs:{id:"autoreleasepool-和-nsrunloop-有什么关系"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool-和-nsrunloop-有什么关系"}},[e._v("#")]),e._v(" AutoreleasePool 和 NSRunloop 有什么关系？")]),e._v(" "),o("p",[e._v("先来个实例看下 "),o("code",[e._v("Runloop")]),e._v(" 是什么东西。建一个普通的 Single View App 工程。点击按钮然后在按钮点击事件里打印")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("- (void)btnPressed:(id)sender {\n    NSRunLoop *runloop = [NSRunLoop currentRunLoop];\n    //在这里打断点然后 po runloop 得到下面结果。（省略大部分无关内容）\n}\n\n(lldb) po runloop\ncommon mode items = <CFBasicHash 0x604000249360 [0x110875bb0]>\n\t1 : <CFRunLoopObserver 0x6040001370c0 [0x110875bb0]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), ....\n\t......\n\t4 : <CFRunLoopObserver 0x604000136ee0 [0x110875bb0]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), ....\n")])])]),o("p",[e._v("注意看上面的 "),o("code",[e._v("activities")]),e._v(",它对应的定义是这里")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("/* Run Loop Observer Activities */\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),\n    kCFRunLoopBeforeTimers = (1UL << 1),\n    kCFRunLoopBeforeSources = (1UL << 2),\n    kCFRunLoopBeforeWaiting = (1UL << 5),\n    kCFRunLoopAfterWaiting = (1UL << 6),\n    kCFRunLoopExit = (1UL << 7),\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n")])])]),o("p",[e._v("可以确定 "),o("code",[e._v("Autorelease")]),e._v(" 机制在 "),o("code",[e._v("Runloop")]),e._v(" 进入和退出(和休眠前触发) "),o("code",[e._v("CommonMode")]),e._v(" 的时候进行观察，当 "),o("code",[e._v("Runloop")]),e._v(" 运行到指定的时机的时候回触发 "),o("code",[e._v("_wrapRunLoopWithAutoreleasePoolHandler")]),e._v(" 回调方法。")]),e._v(" "),o("p",[o("code",[e._v("_wrapRunLoopWithAutoreleasePoolHandler")]),e._v(" 这个方法的实现其实我们并不清楚，网上没有找到对应的实现，不过我们可以打下符号断点来看看有没有线索。果然应用刚启动就执行了这些方法。看左侧的调用栈确实是从 Observer 的回调执行过来的。下面两个是我们熟悉的 Pop 和 Push 操作，"),o("strong",[e._v("基本上可以确认，"),o("code",[e._v("Autorelease")]),e._v(" 机制是在进入 "),o("code",[e._v("Runloop")]),e._v(" 的时候就创建了一个新的 "),o("code",[e._v("AutoreleasePoolPage")]),e._v("。退出或者休眠的的时候回收 "),o("code",[e._v("AutoreleasePoolPage")]),e._v("。")])]),e._v(" "),o("p",[o("img",{attrs:{src:a(355),alt:""}})]),e._v(" "),o("h2",{attrs:{id:"autoreleasepool-和线程有什么关系"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool-和线程有什么关系"}},[e._v("#")]),e._v(" AutoreleasePool 和线程有什么关系?")]),e._v(" "),o("p",[o("code",[e._v("Cocoa")]),e._v(" 应用程序里的每个线程会自动维护一个释放池，就是通过上面 "),o("code",[e._v("Runloop")]),e._v(" 的方式。但是如果没有 "),o("code",[e._v("Runloop")]),e._v(" 呢？")]),e._v(" "),o("p",[e._v("之前看到有人问了一个问题：子线程默认不会开启 "),o("code",[e._v("Runloop")]),e._v("，那出现 "),o("code",[e._v("Autorelease")]),e._v(" 对象如何处理？不手动处理会内存泄漏吗？\n答案是不会。")]),e._v(" "),o("p",[e._v("具体 demo 如下 "),o("a",{attrs:{href:"https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),o("OutboundLink")],1)]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v('- (void)viewDidLoad {\n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil];\n    [thread start];\n}\n\n-(void)test {\n    MyClass *my = [[[MyClass alloc] init] autorelease];\n    NSLog(@"%@",[my description]);\n}\n')])])]),o("p",[e._v("最后的结果是 "),o("code",[e._v("MyClass")]),e._v(" 实例被释放掉了。理论上来说子线程并没有 "),o("code",[e._v("Runloop")]),e._v(" 也就没有自动释放池观察 "),o("code",[e._v("Runloop")]),e._v(" 状态，也就不会自动去执行对应的 "),o("code",[e._v("autorelease")]),e._v(" 的方法。根据引用计数来看的话，"),o("code",[e._v("autorelease")]),e._v(" 方法和 "),o("code",[e._v("AutoreleasePool")]),e._v(" 在一起才能发生作用，而目前又没有 "),o("code",[e._v("AutoreleasePool")]),e._v("，所以那是咋回事？")]),e._v(" "),o("p",[e._v("事实上即使没有 "),o("code",[e._v("Runloop")]),e._v("，线程和 "),o("code",[e._v("AutoreleasePool")]),e._v(" 也能直接发生关系。向某个对象发送 "),o("code",[e._v("autorelease")]),e._v(" 消息后，会自动创建 "),o("code",[e._v("AutoreleasePoolPage")]),e._v("。"),o("code",[e._v("autorelease")]),e._v(" 消息的调用栈可以参考上面的说明。最终 "),o("code",[e._v("TLS")]),e._v("(线程本地存储)会存储 "),o("code",[e._v("AutoreleasePoolPage")]),e._v(" 对象。大致代码如下：")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[e._v("AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);\ntls_set_direct(key, (void *)page);\n")])])]),o("p",[e._v("这里具体实现比较复杂，而且根据是这种情况并不适用于主线程。可以看 "),o("a",{attrs:{href:"https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now",target:"_blank",rel:"noopener noreferrer"}},[e._v("StackOverflow"),o("OutboundLink")],1),e._v(" 的相关回答。这里不具体贴了。")]),e._v(" "),o("p",[e._v("我个人觉得为了程序可读性还有稳定性，还是加上 "),o("code",[e._v("@autoreleasepool")]),e._v(" 更妥。说稳定性是因为不能过度依赖于 "),o("code",[e._v("runtime")]),e._v(" 的底层机制，万一 "),o("code",[e._v("runtime")]),e._v(" 底层机制后续有变化可能会造成程序的异常。")]),e._v(" "),o("h2",{attrs:{id:"什么时候需要我们手动创建-autoreleasepool"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么时候需要我们手动创建-autoreleasepool"}},[e._v("#")]),e._v(" 什么时候需要我们手动创建 AutoreleasePool?")]),e._v(" "),o("ol",[o("li",[e._v("如果工程只是 Foundation-Only(命令行那种),而不是 Cocoa application。那需要手动创建自动释放池。")]),e._v(" "),o("li",[e._v("如果程序存活时间长，而且可能生成大量临时对象（比如循环里创建了一堆）那应该在合适地方（比如循环里）手动释放池，降低内存峰值（不用担心嵌套使用 "),o("code",[e._v("AutoreleasePool")]),e._v(" 的问题）")]),e._v(" "),o("li",[e._v("你创建了一个新线程，需要创建自动释放池。这个跟我们上面一小节说的是略微冲突，但是在上面已经说过了，添加 "),o("code",[e._v("AutoreleasePool")]),e._v(" 是最佳实践。")])]),e._v(" "),o("h3",{attrs:{id:"参考地址"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#参考地址"}},[e._v("#")]),e._v(" 参考地址")]),e._v(" "),o("p",[o("a",{attrs:{href:"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/",target:"_blank",rel:"noopener noreferrer"}},[e._v("黑幕背后的 Autorelease"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://draveness.me/autoreleasepool",target:"_blank",rel:"noopener noreferrer"}},[e._v("自动释放池的前世今生 ---- 深入解析 autoreleasepool"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://blog.ibireme.com/2015/05/18/runloop/",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入理解 RunLoop"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://www.jianshu.com/p/5559bc15490d",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS 中 autorelease 的那些事儿"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226-CH1-SW8",target:"_blank",rel:"noopener noreferrer"}},[e._v("Transitioning to ARC Release Notes"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/occ/cl/NSAutoreleasePool",target:"_blank",rel:"noopener noreferrer"}},[e._v("NSAutoreleasePool"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Using Autorelease Pool Blocks"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"http://www.samirchen.com/ios-arc/",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS ARC 内存管理要点"),o("OutboundLink")],1),e._v(" "),o("a",{attrs:{href:"https://www.jianshu.com/p/f87f40592023",target:"_blank",rel:"noopener noreferrer"}},[e._v("各个线程 Autorelease 对象的内存管理"),o("OutboundLink")],1)])])}),[],!1,null,null,null);o.default=l.exports}}]);