(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{589:function(e,t,a){"use strict";a.r(t);var o=a(5),_=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[t("code",[e._v("@property")]),e._v(" 和 "),t("code",[e._v("attribute")]),e._v(" 的中文翻译都是属性，所以本文就只用英文做区分了。"),t("code",[e._v("property")]),e._v(" 的不同 "),t("code",[e._v("attribute")]),e._v(" 大致包含下面这些")]),e._v(" "),t("ol",[t("li",[e._v("strong //default")]),e._v(" "),t("li",[e._v("weak")]),e._v(" "),t("li",[e._v("copy")]),e._v(" "),t("li",[e._v("assign //default")]),e._v(" "),t("li",[e._v("unsafe_unretained")]),e._v(" "),t("li",[e._v("atomic & nonatomic //default atomic")]),e._v(" "),t("li",[e._v("readonly & readwrite //default readwrite")])]),e._v(" "),t("p",[e._v("接下来依次说一下这些 "),t("code",[e._v("attribute")]),e._v(" 的用处，使用方法还有使用时的可能注意事项")]),e._v(" "),t("h2",{attrs:{id:"strong"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#strong"}},[e._v("#")]),e._v(" strong")]),e._v(" "),t("p",[t("code",[e._v("strong")]),e._v(" 是 "),t("code",[e._v("ARC")]),e._v(" 引入的方便内存管理的一种 "),t("code",[e._v("attribute")]),e._v("，跟 "),t("code",[e._v("MRC")]),e._v(" 属性中的"),t("code",[e._v("retain")]),e._v(" 效果基本是一样的。区别在于编译器遇到 "),t("code",[e._v("strong")]),e._v(" 修饰的变量的时候会自动为其在合适的地方插入一条 "),t("code",[e._v("release")]),e._v(" 语句。相同的地方就是为了强引用属性。强引用的意思就是当前对象持有自己的属性对象，如果当前对象不释放的话这个属性也不会被释放，而当对象释放的时候，"),t("code",[e._v("ARC")]),e._v(" 也会自动为我们处理属性的释放，不需要开发者关心。"),t("code",[e._v("strong")]),e._v(" 是我们最常用的一个 "),t("code",[e._v("attribute")]),e._v("。")]),e._v(" "),t("p",[e._v("几个说明：")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("strong attribute")]),e._v(" 和变量前的修饰符 "),t("code",[e._v("__strong")]),e._v(" 在 "),t("code",[e._v("ARC")]),e._v(" 里的作用是一样的。只不过一个修饰属性一个修饰变量而已。参考 "),t("a",{attrs:{href:"http://clang.llvm.org/docs/AutomaticReferenceCounting.html#property-declarations",target:"_blank",rel:"noopener noreferrer"}},[e._v("Property declarations"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[t("code",[e._v("strong")]),e._v(" 不能用来修饰非对象。否则编译器会报错")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Property with retain(or strong) attribute must be object type\n")])])])]),e._v(" "),t("li",[t("p",[e._v("一般如果某个属性前面不需要显式地写出 "),t("code",[e._v("strong")]),e._v(" 编译器会自动认为这是 "),t("code",[e._v("strong")]),e._v(" 类型的属性。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("strong")]),e._v(" 修饰符会自动处理以下两种 case,而引用计数不会出现异常。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{// 自己生成并持有对象\n    id __strong obj = [[NSObject alloc] init];\n}\n{ // 非自己生成并持有对象.\n    id __strong obj = [NSMutableArray array];\n}\n")])])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("objc_storeStrong")]),e._v(" 方法的说明，当向一个 "),t("code",[e._v("__strong")]),e._v(" 修饰符修饰的对象赋值的时候跟执行下面代码是一样的效果。说白了就是执行了 "),t("code",[e._v("objc_storeStrong")]),e._v(" 的方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//Precondition: object is a valid pointer to a __strong object which\n//is adequately aligned for a pointer. value is null or a pointer to a valid object.\nvoid objc_storeStrong(id *object, id value) {\n  id oldValue = *object;\n  value = [value retain];\n  *object = value;\n  [oldValue release];\n}\n")])])]),t("p",[e._v("值得说明的是 "),t("code",[e._v("FRObject *obj = [FRObject frobj];")]),e._v(" 和 "),t("code",[e._v("FRObject *obj = temp;")]),e._v(" 这两句代码编译器的处理是不一样的。第二句会执行如上 "),t("code",[e._v("objc_storeStrong")]),e._v(" 的方法，但是第一句不会。我个人理解原因是 "),t("code",[e._v("obj")]),e._v(" 初始化的时候并没有 "),t("code",[e._v("oldValue")]),e._v("，所以没有必要这么做。")])])]),e._v(" "),t("h2",{attrs:{id:"weak"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#weak"}},[e._v("#")]),e._v(" weak")]),e._v(" "),t("p",[t("code",[e._v("weak")]),e._v(" 也是 "),t("code",[e._v("ARC")]),e._v(" 引入的方便内存管理的一种 "),t("code",[e._v("attribute")]),e._v("，跟 "),t("code",[e._v("assign")]),e._v(" 效果基本是一样的。区别在于在对象被释放的时候，"),t("code",[e._v("weak")]),e._v(" 机制会自动将对象置为 nil,保证后续访问这个对象不会因为野指针闪退。")]),e._v(" "),t("p",[e._v("真正引入 "),t("code",[e._v("weak")]),e._v(" 的原因是 "),t("code",[e._v("weak")]),e._v(" 能解决引起内存泄露的循环引用问题。")]),e._v(" "),t("p",[e._v("几个说明：")]),e._v(" "),t("ol",[t("li",[t("code",[e._v("weak")]),e._v(" 和 "),t("code",[e._v("strong")]),e._v(" 一样只能用来修饰对象。")]),e._v(" "),t("li",[t("code",[e._v("weak attribute")]),e._v(" 和变量前的修饰符 "),t("code",[e._v("__weak")]),e._v(" 在 "),t("code",[e._v("ARC")]),e._v(" 里的作用是一样的。")])]),e._v(" "),t("h2",{attrs:{id:"copy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copy"}},[e._v("#")]),e._v(" copy")]),e._v(" "),t("p",[t("code",[e._v("copy")]),e._v(" 要求它修饰的属性必须实现 "),t("code",[e._v("NSCopy")]),e._v(" 协议。本质上，当 "),t("code",[e._v("copy")]),e._v(" 修饰的属性被赋值的时候，新值会收到一个 "),t("code",[e._v("copyWithZone")]),e._v(" 方法，旧的值会被 release。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//clang 编译后的源码\nstatic void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) {\nobjc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Fan, _name), (id)name, 1, 1);\n}\n//runtime 里的对应方法\nvoid objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy)\n//reallySetProperty 有对应 copy 属性的具体实现.\n")])])]),t("p",[t("code",[e._v("copy")]),e._v(" 的使用场景通常是你希望属性在赋值后一直保持值不变，而不是跟着它指向的对象一直变。讨论比较多的是 "),t("code",[e._v("NSString")]),e._v(" 是应该用 "),t("code",[e._v("copy")]),e._v(" 还是用 "),t("code",[e._v("strong")]),e._v(" 去修饰")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@property (atomic) NSString *name;\n\nNSMutableString *nameString = [NSMutableString stringWithString:@"John"];\nFan *fan = [[Fan alloc] init];\nfan.name = nameString;\nNSLog(@"fan.name = %@ %p",fan.name,fan.name);\n[nameString appendString:@"ny"];\nNSLog(@"fan.name = %@ %p",fan.name,fan.name);\n//输出结果如下\n2018-01-11 20:35:18.763988+0800 TTTTT[71790:3384299] fan.name = John 0x10051e9c0\n2018-01-11 20:35:18.764449+0800 TTTTT[71790:3384299] fan.name = Johnny 0x10051e9c0\n')])])]),t("p",[e._v("可以看到 "),t("code",[e._v("fan.name")]),e._v(" 在没有显式修改的时候被改掉了，这种情况出现在 "),t("code",[e._v("NSString")]),e._v(" 指针子类 "),t("code",[e._v("NSMutableString")]),e._v(" 的情况下，而 "),t("code",[e._v("NSMutablString")]),e._v(" 的修改不会对本身地址产生影响。使用 "),t("code",[e._v("copy")]),e._v(" 可以避免。个人觉得使用 "),t("code",[e._v("copy")]),e._v(" 还是 "),t("code",[e._v("strong")]),e._v(" 还是根据实际情况，如果出了问题知道为什么就好了。")]),e._v(" "),t("h2",{attrs:{id:"assign"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#assign"}},[e._v("#")]),e._v(" assign")]),e._v(" "),t("p",[e._v("值得注意的是 "),t("code",[e._v("MRC")]),e._v(" 时代和 "),t("code",[e._v("ARC")]),e._v(" 时代的 "),t("code",[e._v("assign")]),e._v(" 使用多少有点区别的。"),t("code",[e._v("MRC")]),e._v(" 的 "),t("code",[e._v("assign")]),e._v(" 是可以修饰对象还有普通基本类型，因为你根本也没得选。但是 "),t("code",[e._v("ARC")]),e._v(" 下虽然 "),t("code",[e._v("assgin")]),e._v(" 也都可以修饰基本类型和对象，但是通常修饰对象的话不会用 "),t("code",[e._v("assign")]),e._v(" ，因为缺少了 "),t("code",[e._v("weak")]),e._v(" 修饰变量被释放时候置为 "),t("code",[e._v("nil")]),e._v(" 的特性，很有可能出现内存问题。所以我们现在用 "),t("code",[e._v("assign")]),e._v(" 修饰基本类型就好了，需要弱引用的时候用 "),t("code",[e._v("weak")]),e._v(" 用来修饰对象。规则也比较明确。")]),e._v(" "),t("h2",{attrs:{id:"unsafe-unretained"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#unsafe-unretained"}},[e._v("#")]),e._v(" unsafe_unretained")]),e._v(" "),t("p",[t("code",[e._v("unsafe_unretained")]),e._v(" 其实就是阉割版本的 "),t("code",[e._v("weak")]),e._v(" 实现，它缺少正是对象释放时候置为 "),t("code",[e._v("nil")]),e._v(" 的特性。但是 "),t("code",[e._v("unsafe_unretained")]),e._v(" 还能修饰基本数据类型，"),t("code",[e._v("weak")]),e._v(" 不行。")]),e._v(" "),t("p",[e._v("看起来，我们使用 weak 就好了为啥要用 "),t("code",[e._v("unsafe_unretained")]),e._v(" 这个属性呢。答案是因为 "),t("code",[e._v("__weak")]),e._v(" 只支持 "),t("code",[e._v("iOS 5.0")]),e._v(" 和 "),t("code",[e._v("OS X Mountain Lion")]),e._v(" 作为部署版本，如果是想要兼容更低的支持 ARC 的版本，比如你想部署回 "),t("code",[e._v("iOS 4.0")]),e._v(" 和 "),t("code",[e._v("OS X Snow Leopark")]),e._v(" 就不得不使用 "),t("code",[e._v("unsafe_unretained")]),e._v("。")]),e._v(" "),t("p",[e._v("还有一种说法是 "),t("code",[e._v("weak")]),e._v(" 底层实现比较繁琐消耗性能，我认为与 "),t("code",[e._v("weak")]),e._v(" 带来的好处相比，这点消耗可以忽略。")]),e._v(" "),t("h2",{attrs:{id:"atomic-nonatomic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#atomic-nonatomic"}},[e._v("#")]),e._v(" atomic & nonatomic")]),e._v(" "),t("p",[t("code",[e._v("atomic")]),e._v(" 和 "),t("code",[e._v("nonatomic")]),e._v(" 区别在于向属性对应成员变量赋值的时候是否为原子写入，即能不能够保证安全写入，从这一点上 "),t("code",[e._v("atomic")]),e._v(" 确实是安全的。但是 "),t("code",[e._v("atomic")]),e._v(" 并非是线程安全的，因为 "),t("code",[e._v("atomic")]),e._v(" 控制的粒度太细了。")]),e._v(" "),t("p",[e._v("举个例子，A 线程向属性写入一个值，A 线程后续再次读这个值之前，可能 B 线程也向同样的属性里写入另外一个值，这样 A 线程读取的时候并非读到的是自己刚写入的值而是一个预期之外的值。")]),e._v(" "),t("p",[e._v("从这一点上看 "),t("code",[e._v("atomic")]),e._v(" 似乎用处不是很大，同时 "),t("code",[e._v("atomic")]),e._v(" 底层是用锁实现的，频繁写入会影响性能。个人认为最好的实践是，使用 "),t("code",[e._v("nonatomic")]),e._v(" 然后自己去处理线程相关的东西。")]),e._v(" "),t("p",[e._v("几个说明：")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("atomic")]),e._v(" 是默认属性。比如 "),t("code",[e._v("@property NSString *name;")]),e._v(" 这种属性默认就是 "),t("code",[e._v("atomic")]),e._v(" 修饰的。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("atomic")]),e._v(" 的底层实现里，赋值和读取值都有锁的保护，而且使用的都是一个锁。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("atomic")]),e._v(" 不允许开发者自己复写其 "),t("code",[e._v("getter")]),e._v(" 方法，强制复写会得到一个警告。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#Writable atomic property 'name' cannot pair a synthesized setter with a user defined getter\n")])])])])]),e._v(" "),t("h2",{attrs:{id:"readonly-readwrite"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#readonly-readwrite"}},[e._v("#")]),e._v(" readonly & readwrite")]),e._v(" "),t("p",[t("code",[e._v("readonly")]),e._v(" 和 "),t("code",[e._v("readwrite")]),e._v(" 其实就是编译器级别帮你做了只读和读写的处理。\n"),t("code",[e._v("readonly")]),e._v(" 是告诉编译器不用生成 "),t("code",[e._v("setter")]),e._v(" 方法，同时如果你对这个 "),t("code",[e._v("readonly")]),e._v(" 属性赋值的时候编译器会报错")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#Assignment to readonly property\n")])])]),t("p",[t("code",[e._v("readwrite")]),e._v(" 是默认的属性，它会告诉编译器自动生成 "),t("code",[e._v("setter")]),e._v(" 和 "),t("code",[e._v("getter")]),e._v(" 方法。开发者可以随意复写这两个方法来满足自己的时机情况。")]),e._v(" "),t("h2",{attrs:{id:"补充关于自动合成属性的声明。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#补充关于自动合成属性的声明。"}},[e._v("#")]),e._v(" 补充关于自动合成属性的声明。")]),e._v(" "),t("p",[t("code",[e._v("Clang")]),e._v(" 提供了对已声明属性自动合成的支持。这个功能提供了没有被 "),t("code",[e._v("@dynamic")]),e._v(" 修饰的属性的 "),t("code",[e._v("getter")]),e._v(" 和 "),t("code",[e._v("setter")]),e._v(" 方法，而不用用户手动添加。")]),e._v(" "),t("p",[e._v("Clang provides support for autosynthesis of declared properties. Using this feature, clang provides default synthesis of those properties not declared @dynamic and not having user provided backing getter and setter methods. __has_feature(objc_default_synthesize_properties) checks for availability of this feature in version of clang being used.")]),e._v(" "),t("h2",{attrs:{id:"一些面试时常遇到的-qa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一些面试时常遇到的-qa"}},[e._v("#")]),e._v(" 一些面试时常遇到的 QA")]),e._v(" "),t("p",[t("strong",[e._v("Q: assign, weak 和 unsafe_unretained 的区别?")]),e._v("\nA: assign 和 unsafe_unretained 是等价的。weak 和它们区别是在对象释放的时候增加了将其置为 "),t("code",[e._v("nil")]),e._v(" 的功能。")]),e._v(" "),t("p",[t("strong",[e._v("Q: atomic 是不是线程安全的？")]),e._v("\nA: 参考上面说明.")]),e._v(" "),t("p",[t("strong",[e._v("Q: "),t("code",[e._v("@property NSString *name;")]),e._v(" 这个属性的 "),t("code",[e._v("attribute")]),e._v(" 是?")]),e._v("\nA: strong,atomic,readwrite.")]),e._v(" "),t("p",[e._v("参考")]),e._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Transitioning to ARC Release Notes"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://clang.llvm.org/docs/AutomaticReferenceCounting.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Objective-C Automatic Reference Counting (ARC)"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://www.vanbein.com/posts/ios%E5%9F%BA%E7%A1%80/2015/12/08/propertyshu-xing-xiu-shi-fu-zong-jie/",target:"_blank",rel:"noopener noreferrer"}},[e._v("property 属性修饰符总结"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://www.ios-blog.co.uk/tutorials/objective-c/objective-c-property-attribute-reference-guide/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Objective-C: Property Attribute Reference Guide"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6",target:"_blank",rel:"noopener noreferrer"}},[e._v("Encapsulating Data"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Variable property attributes or Modifiers in iOS"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=_.exports}}]);