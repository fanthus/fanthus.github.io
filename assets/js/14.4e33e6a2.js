(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{557:function(e,t,a){e.exports=a.p+"assets/img/Untitled.e4de8894.png"},558:function(e,t,a){e.exports=a.p+"assets/img/Untitled_1.e4022c04.png"},559:function(e,t,a){e.exports=a.p+"assets/img/Untitled_2.caa7c34d.png"},560:function(e,t,a){e.exports=a.p+"assets/img/Untitled_3.1693bc06.png"},561:function(e,t,a){e.exports=a.p+"assets/img/Untitled_4.24f749c0.png"},562:function(e,t,a){e.exports=a.p+"assets/img/Untitled_5.bc8a712b.png"},563:function(e,t,a){e.exports=a.p+"assets/img/Untitled_6.ffa49cfe.png"},564:function(e,t,a){e.exports=a.p+"assets/img/Untitled_7.5849e116.png"},690:function(e,t,a){"use strict";a.r(t);var n=a(5),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("野指针是指指向未知或者无效内存地址的指针。出现野指针的场景是实例对象被释放之后，指向对象的指针并没有被置空，还是指向原来的内存地址，这时候访问这个指针就可能会出现野指针错误。野指针错误对应的 Mach Exception 类型 "),t("code",[e._v("EXC_BAD_ACCESS")]),e._v("，对应的 Signal 是 "),t("code",[e._v("SIGSEGV")]),e._v(" 和 "),t("code",[e._v("SIGBUS")]),e._v("。")]),e._v(" "),t("p",[e._v("在 iOS 开发中内存管理从 MRC 向 ARC 以及编程语言从 OC 向 Swift 过度的过程中，野指针问题已经很少出现了，但也还是可能会有相关的野指针的问题，比如 delegate 使用 assign 修饰、使用 "),t("code",[e._v("_unsafe_unretain")]),e._v(" 去修饰对象指针，以及 ARC 对 self 的内存管理（参考Sunny老师的"),t("a",{attrs:{href:"https://blog.sunnyxx.com/2015/01/17/self-in-arc/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇文章"),t("OutboundLink")],1),e._v("），ARC 的机制不光是要保证内存安全，也同时要兼顾性能，所以像上面一些极个别场景下还是会出现内存问题。")]),e._v(" "),t("p",[e._v("所以如何排查定位野指针问题呢？要知道有的时候野指针并不一定会触发崩溃，原因在于 iOS 运行时候去调用析构执行（dealloc）后，只是告诉系统，这片内存我不用了，而系统并没有就让这片内存真的不能访问，所以如果对象释放后内存没有别修改（被其他操作覆盖），则可能不会出现 Crash 或者其他错误。")]),e._v(" "),t("p",[e._v("参考"),t("a",{attrs:{href:"https://shevakuilin.com/ios-crashprotection/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇文章"),t("OutboundLink")],1),e._v("，这里列举对象被释放后，它的内存可能出现的一些变化")]),e._v(" "),t("p",[t("img",{attrs:{src:a(557),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("如果是遇到必现的 Crash 的话还好，能查看内存地址排查，如果遇到非必现的 Crash，排查难度会比较大。")]),e._v(" "),t("p",[e._v("举个例子我们看到的崩溃调用栈不一定是出问题部分的代码，比如 A 部分的代码造成了野指针 P，然后 B 部分代码尝试访问该野指针的时候发生 Crash，则崩溃调用栈显示的是 B 部分代码的调用栈，我们还需要去分析野指针到底是什么时候出现的，参考这里 "),t("em",[t("a",{attrs:{href:"https://developer.apple.com/documentation/xcode/investigating-memory-access-crashes#Investigate-the-crash-with-Xcode",target:"_blank",rel:"noopener noreferrer"}},[e._v("Memory corruption"),t("OutboundLink")],1),e._v("。")])]),e._v(" "),t("p",[e._v("系统提供了一些帮助我们定位排查内存问题的工具。")]),e._v(" "),t("h3",{attrs:{id:"enable-malloc-scribble"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#enable-malloc-scribble"}},[e._v("#")]),e._v(" Enable Malloc Scribble")]),e._v(" "),t("p",[e._v("MallocScribble 本质上是 malloc 库提供的调试用的环境变量。Scribble 的中文含义是涂鸦，这里的含义是为已经分配好的内存填充 0xAA 字符，为已经释放的内存填充 0x55 字符。**MallocScribble 这么做的目的是为了让应该崩溃的场景提早崩溃。**开启位置  Edit Scheme > Diagnostics > Malloc Scribble。")]),e._v(" "),t("p",[e._v("在我们上面描述的场景里，如果对方被释放后对应的内存没有改过，这时候有可能不会 Crash，比如我们向已经释放掉的对象发消息，有可能不会崩溃。我自己并没有制造出类似的崩溃，不过 stackoverflow 上有人遇到过类似的场景 "),t("a",{attrs:{href:"https://stackoverflow.com/questions/1575819/sending-a-message-to-deallocated-object-is-working",target:"_blank",rel:"noopener noreferrer"}},[e._v("Sending a message to deallocated object is working"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("向被释放的实例发送消息是未定义行为，实例被释放了，我们继续向它发送消息，但是执行效果不会复合我们的预期，或者如果系统将被释放的内存改写为别的实例的内存地址，则向该内存地址发送一些 "),t("code",[e._v("NSObject")]),e._v(" 通用的方法并不一定会造成崩溃，但是大概率会造成逻辑错误。这种情况我们一定要尽早发现，这也就是 Malloc Scribble 的使用场景。当对象被释放后，填充 0x55，则向被释放对象发送任何消息一定会触发崩溃。")]),e._v(" "),t("p",[t("img",{attrs:{src:a(558),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("Xcode 提供了这样的调试机制，但是如果交付给测试同学的话，测试同学是没有办法享受到同等的调试待遇的。所以 "),t("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1070505",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bugly 团队"),t("OutboundLink")],1),e._v("通过 fishhook 来动态hook C 语言的 free 方法，hook后的 free方法如下")]),e._v(" "),t("div",{staticClass:"language-objectivec extra-class"},[t("pre",{pre:!0,attrs:{class:"language-objectivec"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("safe_free")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    size_t memSiziee"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("malloc_size")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("memset")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x55")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" memSiziee"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("orig_free")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" \n")])])]),t("p",[e._v("这种做法和 Malloc Scribble 的作用几乎是一模一样的，不过不排除在涂鸦之后，系统将这部分内存再次改写。")]),e._v(" "),t("h3",{attrs:{id:"zombie-objects"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zombie-objects"}},[e._v("#")]),e._v(" Zombie Objects")]),e._v(" "),t("p",[e._v("关于将野指针变为僵尸对象调试有两种方式，关于 Zombie Objects 定义如下")]),e._v(" "),t("p",[e._v("Attempting to further send messages to the object as if it were still a valid object is a “use after free” issue, with the deallocated object still receiving messages called a "),t("em",[e._v("zombie object")]),e._v(".")]),e._v(" "),t("blockquote",[t("p",[e._v("一个对象它死了，又好像没死…")])]),e._v(" "),t("p",[t("strong",[e._v("Instrument Zombie")])]),e._v(" "),t("p",[e._v("我们可以通过 Instrument 提供的 Zombie 工具来发现野指针。")]),e._v(" "),t("p",[e._v("举个例子，有如下按钮点击响应事件的代码(ARC)，当向 stu 指向实例发送消息的时候，stu 指针已经处于野指针状态了，因为 __unsafe_unretained 不会强持有实例，同时当实例释放的时候指针也不会被置为 nil。")]),e._v(" "),t("div",{staticClass:"language-objectivec extra-class"},[t("pre",{pre:!0,attrs:{class:"language-objectivec"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("IBAction"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("trigger"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("sender "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    __unsafe_unretained Person "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("stu "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Person alloc"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" init"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("stu printName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("p",[e._v("开启 Instrument 的 Profile 功能后，我们点击按钮触发上面的逻辑，会看到 Zombie 能检测到向已经释放的对象发消息的时机，同时应用崩溃，记录停止。")]),e._v(" "),t("blockquote",[t("p",[e._v("An Objective-C message was sent to a deallocated 'Person' object (zombie) at address:\n0x60000002c840.")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(559),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("我们点击弹出框中的箭头能看到对应的代码的位置，能看到更详细的关于野指针的信息")]),e._v(" "),t("p",[t("img",{attrs:{src:a(560),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("所以这个 Zombie 工具对于我们调试时排查野指针相关的问题还是挺有帮助的。")]),e._v(" "),t("p",[t("strong",[e._v("Zombie Objects")])]),e._v(" "),t("p",[e._v("通过开启 Zombie Objects（Edit Scheme > Diagnostics > Zombie Objects）之后，在调试的时候遇到崩溃，我们能直接定位到崩溃的位置，同时能获取到相对比较明确的调用栈。")]),e._v(" "),t("p",[e._v("看DEMO 中例子，本来是 Person 类型的 stu 实例在开启 Zombie Objects 之后，变成了 _NSZombie_Person 类型，所以一定是在运行时修改了 stu 的 isa 指针。")]),e._v(" "),t("p",[t("img",{attrs:{src:a(561),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("本质上是运行时 HOOK 了原来的 dealloc 方法，替换为了 "),t("code",[e._v("__dealloc_zombie")]),e._v(" 的实现，就是在此实现中修改了 stu 的 isa 指针，同时调用了 "),t("code",[e._v("objc_destructInstance")]),e._v(" 方法，这个方法的作用是在不释放实例的前提下，移除和实例相关联的引用，和原始 "),t("code",[e._v("dealloc")]),e._v(" 的区别在于，"),t("code",[e._v("__dealloc_zombie")]),e._v(" 并没有真正去调用 free 函数去释放实例内存。")]),e._v(" "),t("blockquote",[t("p",[e._v("可以打 "),t("code",[e._v("__dealloc_zombie")]),e._v(" 符号断点看里面的汇编代码")])]),e._v(" "),t("p",[e._v("同时 isa swizzle 之后 "),t("code",[e._v("_NSZombie_Person")]),e._v(" 类型是没有父类的，并且没有任何方法，所以给他发消息的时候会走消息转发机制，同时会报异常如下")]),e._v(" "),t("blockquote",[t("p",[e._v("-[Person printName]: message sent to deallocated instance 0x108a08180")])]),e._v(" "),t("p",[t("img",{attrs:{src:a(562),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("不管是通过 Xcode 直接开启 Zombie Objects 还是通过 Instrument→Zombie 进行僵尸对象检测，本质上 Zombie 是运行时的环境变量，它将环境变量 "),t("code",[e._v("NSZombieEnabled")]),e._v(" 设置为 "),t("code",[e._v("true")]),e._v(" 。")]),e._v(" "),t("p",[e._v("开启了 Zombie 的注意事项")]),e._v(" "),t("ol",[t("li",[e._v("因为 Zombie 机制是基于运行时实现，所以对于不继承自 "),t("code",[e._v("NSObject")]),e._v(" 的 Swift 实例是不生效的。")]),e._v(" "),t("li",[e._v("Zombies 模板会导致持久内存增长，因为它会更改您的环境，因此从技术上讲，释放的对象永远不会被释放，这是预期的行为。")])]),e._v(" "),t("p",[e._v("Instrument 的 Zombie 工具比环境变量 Zombie 的好处在于能看到野指针的分配和释放历史。")]),e._v(" "),t("h2",{attrs:{id:"guard-malloc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#guard-malloc"}},[e._v("#")]),e._v(" Guard Malloc")]),e._v(" "),t("p",[e._v("Guard Malloc 是 "),t("code",[e._v("malloc")]),e._v(" 库的特殊版本 "),t("code",[e._v("libgmalloc")]),e._v("，在调试期间替代标准库。")]),e._v(" "),t("p",[t("code",[e._v("libgmalloc")]),e._v(" 是在标准系统 "),t("code",[e._v("malloc")]),e._v(" 的位置使用的，它利用虚拟内存系统来识别内存访问错误。每个 "),t("code",[e._v("malloc")]),e._v(" 分配都被放置在其自己的虚拟内存页面（或页面）上。")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("libgmalloc")]),e._v(" 只能用在模拟器上，我们可以通过 "),t("code",[e._v("man libgmalloc")]),e._v(" 命令详细查看 "),t("code",[e._v("libgmalloc")]),e._v(" 的工作方式。")])]),e._v(" "),t("p",[e._v("使用这个工具可以捕获平常不容易发现的越界错误，默认情况下，分配的缓冲区的结束位置位于最后一页的末尾，并且在其后的下一页保持未分配状态。因此，超出缓冲区末尾的访问会立即引发错误。")]),e._v(" "),t("p",[e._v("同时也能捕获野指针相关的错误，当释放内存时，libgmalloc会释放其虚拟内存，因此对已释放的缓冲区的读取或写入会引发错误。难以隔离的错误立即变得明显，我们将确切地知道是哪段代码引起了问题。")]),e._v(" "),t("p",[e._v("下面这段代码如果不开启 Gurad Malloc，运行时候不会出现异常，但并不代表代码没问题，因为这里显然已经越界了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('unsigned *buffer = (unsigned *)malloc(sizeof(unsigned) * 100);\nunsigned i;\nfor (i = 0; i < 200; i++) { buffer[i] = i; }\nfor (i = 0; i < 200; i++) { printf ("%d  ", buffer[i]); }\n')])])]),t("p",[e._v("通过开启 Edit Scheme > Diagnostics > Guard Malloc 后，运行程序，断点会直接打在越界的代码位置，而此时代码正要访问数组界外的内存。")]),e._v(" "),t("p",[t("img",{attrs:{src:a(563),alt:"Untitled"}})]),e._v(" "),t("h2",{attrs:{id:"address-sanitizer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#address-sanitizer"}},[e._v("#")]),e._v(" Address Sanitizer")]),e._v(" "),t("p",[e._v("Address Sanitizer 工具可检测不属于已分配块的内存访问尝试。它是通过自定义实现替换了 "),t("code",[e._v("malloc(_:)")]),e._v(" 和 "),t("code",[e._v("free(_:)")]),e._v(" 函数。")]),e._v(" "),t("p",[e._v("自定义的 "),t("code",[e._v("malloc")]),e._v(" 函数将请求的内存块包围在特殊的禁止访问区域中，并报告试图访问这些区域的尝试。"),t("code",[e._v("free")]),e._v(" 函数将释放的块放入特殊的隔离队列中，并报告试图访问该隔离内存的尝试。")]),e._v(" "),t("p",[e._v("我们还是沿用上面(Guard Malloc)部分的例子，开启 Edit Scheme > Diagnostics > Address Sanitizer 后运行代码，定位到了越界的位置。")]),e._v(" "),t("p",[t("img",{attrs:{src:a(564),alt:"Untitled"}})]),e._v(" "),t("p",[e._v("以上基本上就是系统层面提供的一些处理野指针的方式… 感觉系统的的一些监控野指针的方式就是通过各种 HOOK 系统函数的方式，总结一下就是，Malloc Scribble 是通过 hook malloc 和 free 修改内存填充数据；Zombie Objects 通过 hook dealloc 方法不去真正释放对象并修改对象的 isa 指针；Address Sanitizer 也是 hook malloc 和 free 方法来检测内存越界和野指针的错误；Guard Malloc 是干脆替换了 malloc 内存分配库。")]),e._v(" "),t("p",[e._v("参考地址:")]),e._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6930979515552235528",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS 野指针处理"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1070505",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何定位Obj-C野指针随机Crash(一)：先提高野指针Crash率"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://shevakuilin.com/ios-crashprotection/",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅谈 iOS 中的 Crash 捕获与防护"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/documentation/xcode/investigating-memory-access-crashes",target:"_blank",rel:"noopener noreferrer"}},[e._v("Xcode-Investigating memory access crashes"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Memory Usage Performance Guidelines-Configuring the Malloc Environment Variables"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/library/archive/technotes/tn2239/_index.html#//apple_ref/doc/uid/DTS40010638-CH1-SUBSECTION19",target:"_blank",rel:"noopener noreferrer"}},[e._v("Technical Note TN2239-iOS Debugging Magic"),t("OutboundLink")],1),e._v(" #bsd")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/documentation/xcode/investigating-crashes-for-zombie-objects",target:"_blank",rel:"noopener noreferrer"}},[e._v("Xcode-Investigating crashes for zombie objects"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://help.apple.com/instruments/mac/current/#/dev612e6956",target:"_blank",rel:"noopener noreferrer"}},[e._v("Instruments-Finding zombies"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/493f581d336b",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS Zombie Objects(僵尸对象)原理探索"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://stackoverflow.com/questions/59236757/why-does-object-become-nszombie-only-when-inherit-from-nsobject",target:"_blank",rel:"noopener noreferrer"}},[e._v("Why does object become NSZombie only when inherit from NSObject?"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/7314558335817809947#heading-8",target:"_blank",rel:"noopener noreferrer"}},[e._v("野指针扑获理论篇"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://keith.github.io/xcode-man-pages/libgmalloc.3.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("man-libgmalloc"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://stackoverflow.com/questions/9590350/xcode-scribble-guard-edges-and-guard-malloc",target:"_blank",rel:"noopener noreferrer"}},[e._v("Xcode - scribble, guard edges and guard malloc"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/67067edebf62",target:"_blank",rel:"noopener noreferrer"}},[e._v("初识Enable Guard Malloc"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early",target:"_blank",rel:"noopener noreferrer"}},[e._v("Xcode Debugging-Diagnosing memory, thread, and crash issues early"),t("OutboundLink")],1),e._v(" #Address Sanitizer")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://useyourloaf.com/blog/using-the-address-sanitizer/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Using the Address Sanitizer"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("WWDC 2015 Session 413 Advanced Debugging and the Address Sanitizer")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.mikeash.com/pyblog/friday-qa-2015-07-03-address-sanitizer.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Friday Q&A 2015-07-03: Address Sanitizer"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/7055496484325687304",target:"_blank",rel:"noopener noreferrer"}},[e._v("iOS 线上野指针探测实践与展望"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=r.exports}}]);